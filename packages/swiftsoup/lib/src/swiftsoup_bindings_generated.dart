// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by ffigen from SwiftSoupWrapper-Swift.h.

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint, unused_import
@ffi.DefaultAsset('package:swiftsoup/src/swiftsoup_bindings_generated.dart')
library;

import 'dart:ffi' as ffi;
import 'package:objective_c/objective_c.dart' as objc;
import 'package:ffi/ffi.dart' as pkg_ffi;

@ffi.Native<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)>()
external bool _SwiftSoupBindings_protocolTrampoline_e3qsqz(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SwiftSoupBindings_wrapListenerBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SwiftSoupBindings_wrapBlockingBlock_ovsamd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)>()
external void _SwiftSoupBindings_protocolTrampoline_ovsamd(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SwiftSoupBindings_wrapListenerBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SwiftSoupBindings_wrapBlockingBlock_pfv6jd(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>)>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SwiftSoupBindings_wrapListenerBlock_1b3bb6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCBlockImpl> Function(
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
    ffi.Pointer<objc.DOBJC_Context>,
  )
>(isLeaf: true)
external ffi.Pointer<objc.ObjCBlockImpl> _SwiftSoupBindings_wrapBlockingBlock_1b3bb6a(
  ffi.Pointer<objc.ObjCBlockImpl> block,
  ffi.Pointer<objc.ObjCBlockImpl> listnerBlock,
  ffi.Pointer<objc.DOBJC_Context> context,
);

@ffi.Native<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)>()
external ffi.Pointer<objc.ObjCObjectImpl> _SwiftSoupBindings_protocolTrampoline_1mbt9g9(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
);

@ffi.Native<
  instancetype Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
  )
>()
external instancetype _SwiftSoupBindings_protocolTrampoline_10z9f5k(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
);

@ffi.Native<
  ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
>()
external int _SwiftSoupBindings_protocolTrampoline_1ldqghh(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
);

@ffi.Native<
  ffi.Pointer<objc.ObjCObjectImpl> Function(
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<ffi.Void>,
    ffi.Pointer<objc.ObjCObjectImpl>,
    ffi.Pointer<objc.ObjCBlockImpl>,
  )
>()
external ffi.Pointer<objc.ObjCObjectImpl> _SwiftSoupBindings_protocolTrampoline_1q0i84(
  ffi.Pointer<objc.ObjCObjectImpl> target,
  ffi.Pointer<ffi.Void> arg0,
  ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ffi.Pointer<objc.ObjCBlockImpl> arg2,
);

late final _class_NSObject = objc.getClass("NSObject");
late final _sel_version = objc.registerName("version");
final _objc_msgSend_1hz7y9r = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_setVersion_ = objc.registerName("setVersion:");
final _objc_msgSend_4sp4xj = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Long)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_classForCoder = objc.registerName("classForCoder");
final _objc_msgSend_151sglz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_replacementObjectForCoder_ = objc.registerName("replacementObjectForCoder:");
final _objc_msgSend_1sotr3r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_awakeAfterUsingCoder_ = objc.registerName("awakeAfterUsingCoder:");

/// NSCoderMethods
extension NSCoderMethods on objc.NSObject {
  /// awakeAfterUsingCoder:
  objc.ObjCObject? awakeAfterUsingCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal('NSObject.awakeAfterUsingCoder:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_awakeAfterUsingCoder_,
      coder.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// classForCoder
  objc.ObjCObject get classForCoder {
    objc.checkOsVersionInternal('NSObject.classForCoder', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_classForCoder);
    return objc.ObjCObject($ret, retain: true, release: true);
  }

  /// replacementObjectForCoder:
  objc.ObjCObject? replacementObjectForCoder(objc.NSCoder coder) {
    objc.checkOsVersionInternal(
      'NSObject.replacementObjectForCoder:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_replacementObjectForCoder_, coder.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// setVersion:
  static void setVersion(int aVersion) {
    objc.checkOsVersionInternal('NSObject.setVersion:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_4sp4xj(_class_NSObject, _sel_setVersion_, aVersion);
  }

  /// version
  static int version() {
    objc.checkOsVersionInternal('NSObject.version', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1hz7y9r(_class_NSObject, _sel_version);
  }
}

late final _sel_poseAsClass_ = objc.registerName("poseAsClass:");
final _objc_msgSend_xtuoz7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObjectImpl>)
    >();

/// NSDeprecatedMethods
extension NSDeprecatedMethods on objc.NSObject {
  /// poseAsClass:
  static void poseAsClass(objc.ObjCObject aClass) {
    objc.checkOsVersionInternal('NSObject.poseAsClass:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_xtuoz7(_class_NSObject, _sel_poseAsClass_, aClass.ref.pointer);
  }
}

late final _protocol_NSDiscardableContent = objc.getProtocol("NSDiscardableContent");
late final _sel_conformsToProtocol_ = objc.registerName("conformsToProtocol:");
final _objc_msgSend_e3qsqz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCProtocolImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCProtocolImpl>,
      )
    >();
late final _sel_beginContentAccess = objc.registerName("beginContentAccess");
final _objc_msgSend_91o635 = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>();

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_bool_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> fromFunction(
    bool Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  static bool _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
        false,
      ).cast();
  static bool _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as bool Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
        false,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_bool_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<ffi.Void>)> {
  bool call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<bool Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_endContentAccess = objc.registerName("endContentAccess");
final _objc_msgSend_1pl9qdv = objc.msgSendPointer
    .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>();

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_ffiVoid_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> fromFunction(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(_closureCallable, (ffi.Pointer<ffi.Void> arg0) => fn(arg0), keepIsolateAlive),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> listener(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapListenerBlock_ovsamd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> blocking(
    void Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapBlockingBlock_ovsamd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>
  _listenerCallable =
      ffi.NativeCallable<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>.listener(
        _listenerTrampoline,
      )..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<ffi.Void> arg0,
  ) {
    try {
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _fnPtrTrampoline,
      ).cast();
  static void _closureTrampoline(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0) =>
      (objc.getBlockClosure(block) as void Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>(
        _closureTrampoline,
      ).cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_ffiVoid_ffiVoid$CallExtension on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<ffi.Void>)> {
  void call(ffi.Pointer<ffi.Void> arg0) => ref.pointer.ref.invoke
      .cast<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<void Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)>()(ref.pointer, arg0);
}

late final _sel_discardContentIfPossible = objc.registerName("discardContentIfPossible");
late final _sel_isContentDiscarded = objc.registerName("isContentDiscarded");

/// NSDiscardableContent
extension type NSDiscardableContent._(objc.ObjCProtocol object$) implements objc.ObjCProtocol {
  /// Constructs a [NSDiscardableContent] that points to the same underlying object as [other].
  NSDiscardableContent.as(objc.ObjCObject other) : object$ = other;

  /// Constructs a [NSDiscardableContent] that wraps the given raw object pointer.
  NSDiscardableContent.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other, {bool retain = false, bool release = false})
    : object$ = objc.ObjCProtocol(other, retain: retain, release: release);

  /// Returns whether [obj] is an instance of [NSDiscardableContent].
  static bool conformsTo(objc.ObjCObject obj) {
    return _objc_msgSend_e3qsqz(obj.ref.pointer, _sel_conformsToProtocol_, _protocol_NSDiscardableContent);
  }
}

extension NSDiscardableContent$Methods on NSDiscardableContent {
  /// beginContentAccess
  bool beginContentAccess() {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_beginContentAccess);
  }

  /// discardContentIfPossible
  void discardContentIfPossible() {
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_discardContentIfPossible);
  }

  /// endContentAccess
  void endContentAccess() {
    _objc_msgSend_1pl9qdv(object$.ref.pointer, _sel_endContentAccess);
  }

  /// isContentDiscarded
  bool isContentDiscarded() {
    return _objc_msgSend_91o635(object$.ref.pointer, _sel_isContentDiscarded);
  }
}

interface class NSDiscardableContent$Builder {
  /// Returns the [objc.Protocol] object for this protocol.
  static objc.Protocol get $protocol => objc.Protocol.fromPointer(_protocol_NSDiscardableContent.cast());

  /// Builds an object that implements the NSDiscardableContent protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSDiscardableContent implement({
    required bool Function() beginContentAccess,
    required void Function() discardContentIfPossible,
    required void Function() endContentAccess,
    required bool Function() isContentDiscarded,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSDiscardableContent');
    NSDiscardableContent$Builder.beginContentAccess.implement(builder, beginContentAccess);
    NSDiscardableContent$Builder.discardContentIfPossible.implement(builder, discardContentIfPossible);
    NSDiscardableContent$Builder.endContentAccess.implement(builder, endContentAccess);
    NSDiscardableContent$Builder.isContentDiscarded.implement(builder, isContentDiscarded);
    builder.addProtocol($protocol);
    return NSDiscardableContent.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSDiscardableContent protocol to an existing
  /// [objc.ObjCProtocolBuilder].
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilder(
    objc.ObjCProtocolBuilder builder, {
    required bool Function() beginContentAccess,
    required void Function() discardContentIfPossible,
    required void Function() endContentAccess,
    required bool Function() isContentDiscarded,
    bool $keepIsolateAlive = true,
  }) {
    NSDiscardableContent$Builder.beginContentAccess.implement(builder, beginContentAccess);
    NSDiscardableContent$Builder.discardContentIfPossible.implement(builder, discardContentIfPossible);
    NSDiscardableContent$Builder.endContentAccess.implement(builder, endContentAccess);
    NSDiscardableContent$Builder.isContentDiscarded.implement(builder, isContentDiscarded);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSDiscardableContent protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSDiscardableContent implementAsListener({
    required bool Function() beginContentAccess,
    required void Function() discardContentIfPossible,
    required void Function() endContentAccess,
    required bool Function() isContentDiscarded,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSDiscardableContent');
    NSDiscardableContent$Builder.beginContentAccess.implement(builder, beginContentAccess);
    NSDiscardableContent$Builder.discardContentIfPossible.implementAsListener(builder, discardContentIfPossible);
    NSDiscardableContent$Builder.endContentAccess.implementAsListener(builder, endContentAccess);
    NSDiscardableContent$Builder.isContentDiscarded.implement(builder, isContentDiscarded);
    builder.addProtocol($protocol);
    return NSDiscardableContent.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSDiscardableContent protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as listeners will
  /// be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsListener(
    objc.ObjCProtocolBuilder builder, {
    required bool Function() beginContentAccess,
    required void Function() discardContentIfPossible,
    required void Function() endContentAccess,
    required bool Function() isContentDiscarded,
    bool $keepIsolateAlive = true,
  }) {
    NSDiscardableContent$Builder.beginContentAccess.implement(builder, beginContentAccess);
    NSDiscardableContent$Builder.discardContentIfPossible.implementAsListener(builder, discardContentIfPossible);
    NSDiscardableContent$Builder.endContentAccess.implementAsListener(builder, endContentAccess);
    NSDiscardableContent$Builder.isContentDiscarded.implement(builder, isContentDiscarded);
    builder.addProtocol($protocol);
  }

  /// Builds an object that implements the NSDiscardableContent protocol. To implement
  /// multiple protocols, use [addToBuilder] or [objc.ObjCProtocolBuilder] directly. All
  /// methods that can be implemented as blocking listeners will be.
  ///
  /// If `$keepIsolateAlive` is true, this protocol will keep this isolate
  /// alive until it is garbage collected by both Dart and ObjC.
  static NSDiscardableContent implementAsBlocking({
    required bool Function() beginContentAccess,
    required void Function() discardContentIfPossible,
    required void Function() endContentAccess,
    required bool Function() isContentDiscarded,
    bool $keepIsolateAlive = true,
  }) {
    final builder = objc.ObjCProtocolBuilder(debugName: 'NSDiscardableContent');
    NSDiscardableContent$Builder.beginContentAccess.implement(builder, beginContentAccess);
    NSDiscardableContent$Builder.discardContentIfPossible.implementAsBlocking(builder, discardContentIfPossible);
    NSDiscardableContent$Builder.endContentAccess.implementAsBlocking(builder, endContentAccess);
    NSDiscardableContent$Builder.isContentDiscarded.implement(builder, isContentDiscarded);
    builder.addProtocol($protocol);
    return NSDiscardableContent.as(builder.build(keepIsolateAlive: $keepIsolateAlive));
  }

  /// Adds the implementation of the NSDiscardableContent protocol to an existing
  /// [objc.ObjCProtocolBuilder]. All methods that can be implemented as blocking
  /// listeners will be.
  ///
  /// Note: You cannot call this method after you have called `builder.build`.
  static void addToBuilderAsBlocking(
    objc.ObjCProtocolBuilder builder, {
    required bool Function() beginContentAccess,
    required void Function() discardContentIfPossible,
    required void Function() endContentAccess,
    required bool Function() isContentDiscarded,
    bool $keepIsolateAlive = true,
  }) {
    NSDiscardableContent$Builder.beginContentAccess.implement(builder, beginContentAccess);
    NSDiscardableContent$Builder.discardContentIfPossible.implementAsBlocking(builder, discardContentIfPossible);
    NSDiscardableContent$Builder.endContentAccess.implementAsBlocking(builder, endContentAccess);
    NSDiscardableContent$Builder.isContentDiscarded.implement(builder, isContentDiscarded);
    builder.addProtocol($protocol);
  }

  /// beginContentAccess
  static final beginContentAccess = objc.ObjCProtocolMethod<bool Function()>(
    _protocol_NSDiscardableContent,
    _sel_beginContentAccess,
    ffi.Native.addressOf<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)>
        >(_SwiftSoupBindings_protocolTrampoline_e3qsqz)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDiscardableContent,
      _sel_beginContentAccess,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
  );

  /// discardContentIfPossible
  static final discardContentIfPossible = objc.ObjCProtocolListenableMethod<void Function()>(
    _protocol_NSDiscardableContent,
    _sel_discardContentIfPossible,
    ffi.Native.addressOf<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)>
        >(_SwiftSoupBindings_protocolTrampoline_ovsamd)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDiscardableContent,
      _sel_discardContentIfPossible,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.fromFunction(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.listener(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.blocking(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
  );

  /// endContentAccess
  static final endContentAccess = objc.ObjCProtocolListenableMethod<void Function()>(
    _protocol_NSDiscardableContent,
    _sel_endContentAccess,
    ffi.Native.addressOf<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)>
        >(_SwiftSoupBindings_protocolTrampoline_ovsamd)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDiscardableContent,
      _sel_endContentAccess,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.fromFunction(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.listener(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
    (void Function() func) => ObjCBlock_ffiVoid_ffiVoid.blocking(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
  );

  /// isContentDiscarded
  static final isContentDiscarded = objc.ObjCProtocolMethod<bool Function()>(
    _protocol_NSDiscardableContent,
    _sel_isContentDiscarded,
    ffi.Native.addressOf<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<ffi.Void>)>
        >(_SwiftSoupBindings_protocolTrampoline_e3qsqz)
        .cast(),
    objc.getProtocolMethodSignature(
      _protocol_NSDiscardableContent,
      _sel_isContentDiscarded,
      isRequired: true,
      isInstanceMethod: true,
    ),
    (bool Function() func) => ObjCBlock_bool_ffiVoid.fromFunction(
      (
        ffi.Pointer<ffi.Void> _,
      ) => func(),
    ),
  );
}

late final _sel_autoContentAccessingProxy = objc.registerName("autoContentAccessingProxy");

/// NSDiscardableContentProxy
extension NSDiscardableContentProxy on objc.NSObject {
  /// autoContentAccessingProxy
  objc.ObjCObject get autoContentAccessingProxy {
    objc.checkOsVersionInternal(
      'NSObject.autoContentAccessingProxy',
      iOS: (false, (4, 0, 0)),
      macOS: (false, (10, 6, 0)),
    );
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_autoContentAccessingProxy);
    return objc.ObjCObject($ret, retain: true, release: true);
  }
}

late final _class_NSValue = objc.getClass("NSValue");
late final _sel_valueWithBytes_objCType_ = objc.registerName("valueWithBytes:objCType:");
final _objc_msgSend_e9mncn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Char>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
        ffi.Pointer<ffi.Char>,
      )
    >();
late final _sel_value_withObjCType_ = objc.registerName("value:withObjCType:");

/// NSValueCreation
extension NSValueCreation on objc.NSValue {
  /// value:withObjCType:
  static objc.NSValue value(ffi.Pointer<ffi.Void> value, {required ffi.Pointer<ffi.Char> withObjCType}) {
    final $ret = _objc_msgSend_e9mncn(_class_NSValue, _sel_value_withObjCType_, value, withObjCType);
    return objc.NSValue.fromPointer($ret, retain: true, release: true);
  }

  /// valueWithBytes:objCType:
  static objc.NSValue valueWithBytes(ffi.Pointer<ffi.Void> value, {required ffi.Pointer<ffi.Char> objCType}) {
    final $ret = _objc_msgSend_e9mncn(_class_NSValue, _sel_valueWithBytes_objCType_, value, objCType);
    return objc.NSValue.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_valueWithNonretainedObject_ = objc.registerName("valueWithNonretainedObject:");
late final _sel_nonretainedObjectValue = objc.registerName("nonretainedObjectValue");
late final _sel_valueWithPointer_ = objc.registerName("valueWithPointer:");
final _objc_msgSend_1mbt9g9 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Void>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Void>,
      )
    >();
late final _sel_pointerValue = objc.registerName("pointerValue");
final _objc_msgSend_6ex6p5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_isEqualToValue_ = objc.registerName("isEqualToValue:");
final _objc_msgSend_19nvye5 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObjectImpl>)
    >();

/// NSValueExtensionMethods
extension NSValueExtensionMethods on objc.NSValue {
  /// isEqualToValue:
  bool isEqualToValue(objc.NSValue value) {
    return _objc_msgSend_19nvye5(object$.ref.pointer, _sel_isEqualToValue_, value.ref.pointer);
  }

  /// nonretainedObjectValue
  objc.ObjCObject? get nonretainedObjectValue {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_nonretainedObjectValue);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// pointerValue
  ffi.Pointer<ffi.Void> get pointerValue {
    return _objc_msgSend_6ex6p5(object$.ref.pointer, _sel_pointerValue);
  }

  /// valueWithNonretainedObject:
  static objc.NSValue valueWithNonretainedObject(objc.ObjCObject? anObject) {
    final $ret = _objc_msgSend_1sotr3r(
      _class_NSValue,
      _sel_valueWithNonretainedObject_,
      anObject?.ref.pointer ?? ffi.nullptr,
    );
    return objc.NSValue.fromPointer($ret, retain: true, release: true);
  }

  /// valueWithPointer:
  static objc.NSValue valueWithPointer(ffi.Pointer<ffi.Void> pointer) {
    final $ret = _objc_msgSend_1mbt9g9(_class_NSValue, _sel_valueWithPointer_, pointer);
    return objc.NSValue.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_getValue_ = objc.registerName("getValue:");
final _objc_msgSend_ovsamd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Void>)
    >();

/// NSDeprecated
extension NSDeprecated$1 on objc.NSValue {
  /// getValue:
  void getValue$1(ffi.Pointer<ffi.Void> value) {
    objc.checkOsVersionInternal('NSValue.getValue:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_ovsamd(object$.ref.pointer, _sel_getValue_, value);
  }
}

late final _sel_valueWithRange_ = objc.registerName("valueWithRange:");
final _objc_msgSend_1k1o1s7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          objc.NSRange,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        objc.NSRange,
      )
    >();
late final _sel_rangeValue = objc.registerName("rangeValue");
final _objc_msgSend_1u11dbb = objc.msgSendPointer
    .cast<ffi.NativeFunction<objc.NSRange Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>>()
    .asFunction<objc.NSRange Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>();
final _objc_msgSend_1u11dbbStret = objc.msgSendStretPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.NSRange>, ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.NSRange>, ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
    >();

/// NSValueRangeExtensions
extension NSValueRangeExtensions on objc.NSValue {
  /// rangeValue
  objc.NSRange get rangeValue {
    final $ptr = pkg_ffi.calloc<objc.NSRange>();
    objc.useMsgSendVariants
        ? _objc_msgSend_1u11dbbStret($ptr, object$.ref.pointer, _sel_rangeValue)
        : $ptr.ref = _objc_msgSend_1u11dbb(object$.ref.pointer, _sel_rangeValue);
    final $finalizable = $ptr.cast<ffi.Uint8>().asTypedList(
      ffi.sizeOf<objc.NSRange>(),
      finalizer: pkg_ffi.calloc.nativeFree,
    );
    return ffi.Struct.create<objc.NSRange>($finalizable);
  }

  /// valueWithRange:
  static objc.NSValue valueWithRange(objc.NSRange range) {
    final $ret = _objc_msgSend_1k1o1s7(_class_NSValue, _sel_valueWithRange_, range);
    return objc.NSValue.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_NSArray = objc.getClass("NSArray");
typedef instancetype = ffi.Pointer<objc.ObjCObjectImpl>;
typedef Dartinstancetype = objc.ObjCObject;
late final _sel_array = objc.registerName("array");
late final _sel_arrayWithObject_ = objc.registerName("arrayWithObject:");
late final _sel_arrayWithObjects_count_ = objc.registerName("arrayWithObjects:count:");
final _objc_msgSend_zmbtbd = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        int,
      )
    >();
late final _sel_arrayWithObjects_ = objc.registerName("arrayWithObjects:");
late final _sel_arrayWithArray_ = objc.registerName("arrayWithArray:");
late final _sel_initWithObjects_ = objc.registerName("initWithObjects:");
late final _sel_initWithArray_ = objc.registerName("initWithArray:");
late final _sel_initWithArray_copyItems_ = objc.registerName("initWithArray:copyItems:");
final _objc_msgSend_17amj0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();
late final _sel_initWithContentsOfURL_error_ = objc.registerName("initWithContentsOfURL:error:");
final _objc_msgSend_1lhpu4m = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_arrayWithContentsOfURL_error_ = objc.registerName("arrayWithContentsOfURL:error:");

/// NSArrayCreation
extension NSArrayCreation on objc.NSArray {
  /// initWithArray:
  objc.NSArray initWithArray(objc.NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(object$.ref.retainAndReturnPointer(), _sel_initWithArray_, array.ref.pointer);
    return objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// initWithArray:copyItems:
  objc.NSArray initWithArray$1(objc.NSArray array, {required bool copyItems}) {
    final $ret = _objc_msgSend_17amj0z(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithArray_copyItems_,
      array.ref.pointer,
      copyItems,
    );
    return objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:error:
  objc.NSArray? initWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSArray.initWithContentsOfURL:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1lhpu4m(
        object$.ref.retainAndReturnPointer(),
        _sel_initWithContentsOfURL_error_,
        url.ref.pointer,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: false, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// initWithObjects:
  objc.NSArray initWithObjects$1(objc.ObjCObject firstObj) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithObjects_,
      firstObj.ref.pointer,
    );
    return objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// array
  static objc.NSArray array() {
    final $ret = _objc_msgSend_151sglz(_class_NSArray, _sel_array);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithArray:
  static objc.NSArray arrayWithArray(objc.NSArray array) {
    final $ret = _objc_msgSend_1sotr3r(_class_NSArray, _sel_arrayWithArray_, array.ref.pointer);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithContentsOfURL:error:
  static objc.NSArray? arrayWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSArray.arrayWithContentsOfURL:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1lhpu4m(_class_NSArray, _sel_arrayWithContentsOfURL_error_, url.ref.pointer, $err);
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// arrayWithObject:
  static objc.NSArray arrayWithObject(objc.ObjCObject anObject) {
    final $ret = _objc_msgSend_1sotr3r(_class_NSArray, _sel_arrayWithObject_, anObject.ref.pointer);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:
  static objc.NSArray arrayWithObjects(objc.ObjCObject firstObj) {
    final $ret = _objc_msgSend_1sotr3r(_class_NSArray, _sel_arrayWithObjects_, firstObj.ref.pointer);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithObjects:count:
  static objc.NSArray arrayWithObjects$1(ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> objects, {required int count}) {
    final $ret = _objc_msgSend_zmbtbd(_class_NSArray, _sel_arrayWithObjects_count_, objects, count);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
abstract final class ObjCBlock_bool_objcObjCObjectImpl_objcObjCObjectImpl {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>
  fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>(
        pointer,
        retain: retain,
        release: release,
      );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>
  fromFunction(bool Function(objc.ObjCObject, objc.ObjCObject) fn, {bool keepIsolateAlive = true}) =>
      objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
            objc.ObjCObject(arg0, retain: true, release: true),
            objc.ObjCObject(arg1, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static bool _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
        >
      >()
      .asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline, false)
          .cast();
  static bool _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Bool Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline, false)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>`.
extension ObjCBlock_bool_objcObjCObjectImpl_objcObjCObjectImpl$CallExtension
    on objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)> {
  bool call(objc.ObjCObject arg0, objc.ObjCObject arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Bool Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        bool Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer);
}

late final _sel_differenceFromArray_withOptions_usingEquivalenceTest_ = objc.registerName(
  "differenceFromArray:withOptions:usingEquivalenceTest:",
);
final _objc_msgSend_1415lvo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();
late final _sel_differenceFromArray_withOptions_ = objc.registerName("differenceFromArray:withOptions:");
final _objc_msgSend_1wtpmu7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_differenceFromArray_ = objc.registerName("differenceFromArray:");
late final _sel_arrayByApplyingDifference_ = objc.registerName("arrayByApplyingDifference:");

/// NSArrayDiffing
extension NSArrayDiffing on objc.NSArray {
  /// arrayByApplyingDifference:
  objc.NSArray? arrayByApplyingDifference(objc.NSOrderedCollectionDifference difference) {
    objc.checkOsVersionInternal(
      'NSArray.arrayByApplyingDifference:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_arrayByApplyingDifference_, difference.ref.pointer);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// differenceFromArray:
  objc.NSOrderedCollectionDifference differenceFromArray(objc.NSArray other) {
    objc.checkOsVersionInternal('NSArray.differenceFromArray:', iOS: (false, (13, 0, 0)), macOS: (false, (10, 15, 0)));
    final $ret = _objc_msgSend_1sotr3r(object$.ref.pointer, _sel_differenceFromArray_, other.ref.pointer);
    return objc.NSOrderedCollectionDifference.fromPointer($ret, retain: true, release: true);
  }

  /// differenceFromArray:withOptions:
  objc.NSOrderedCollectionDifference differenceFromArray$1(objc.NSArray other, {required int withOptions}) {
    objc.checkOsVersionInternal(
      'NSArray.differenceFromArray:withOptions:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1wtpmu7(
      object$.ref.pointer,
      _sel_differenceFromArray_withOptions_,
      other.ref.pointer,
      withOptions,
    );
    return objc.NSOrderedCollectionDifference.fromPointer($ret, retain: true, release: true);
  }

  /// differenceFromArray:withOptions:usingEquivalenceTest:
  objc.NSOrderedCollectionDifference differenceFromArray$2(
    objc.NSArray other, {
    required int withOptions,
    required objc.ObjCBlock<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>
    usingEquivalenceTest,
  }) {
    objc.checkOsVersionInternal(
      'NSArray.differenceFromArray:withOptions:usingEquivalenceTest:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    final $ret = _objc_msgSend_1415lvo(
      object$.ref.pointer,
      _sel_differenceFromArray_withOptions_usingEquivalenceTest_,
      other.ref.pointer,
      withOptions,
      usingEquivalenceTest.ref.pointer,
    );
    return objc.NSOrderedCollectionDifference.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_getObjects_ = objc.registerName("getObjects:");
final _objc_msgSend_1dau4w = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();
late final _sel_arrayWithContentsOfFile_ = objc.registerName("arrayWithContentsOfFile:");
late final _sel_arrayWithContentsOfURL_ = objc.registerName("arrayWithContentsOfURL:");
late final _sel_initWithContentsOfFile_ = objc.registerName("initWithContentsOfFile:");
late final _sel_initWithContentsOfURL_ = objc.registerName("initWithContentsOfURL:");
late final _sel_writeToFile_atomically_ = objc.registerName("writeToFile:atomically:");
final _objc_msgSend_1iyq28l = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
      )
    >();
late final _sel_writeToURL_atomically_ = objc.registerName("writeToURL:atomically:");

/// NSDeprecated
extension NSDeprecated on objc.NSArray {
  /// getObjects:
  void getObjects(ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> objects) {
    objc.checkOsVersionInternal('NSArray.getObjects:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1dau4w(object$.ref.pointer, _sel_getObjects_, objects);
  }

  /// initWithContentsOfFile:
  objc.NSArray? initWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal('NSArray.initWithContentsOfFile:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.NSArray? initWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSArray.initWithContentsOfURL:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: false, release: true);
  }

  /// writeToFile:atomically:
  bool writeToFile(objc.NSString path, {required bool atomically}) {
    objc.checkOsVersionInternal('NSArray.writeToFile:atomically:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToFile_atomically_, path.ref.pointer, atomically);
  }

  /// writeToURL:atomically:
  bool writeToURL(objc.NSURL url, {required bool atomically}) {
    objc.checkOsVersionInternal('NSArray.writeToURL:atomically:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToURL_atomically_, url.ref.pointer, atomically);
  }

  /// arrayWithContentsOfFile:
  static objc.NSArray? arrayWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal(
      'NSArray.arrayWithContentsOfFile:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(_class_NSArray, _sel_arrayWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithContentsOfURL:
  static objc.NSArray? arrayWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSArray.arrayWithContentsOfURL:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(_class_NSArray, _sel_arrayWithContentsOfURL_, url.ref.pointer);
    return $ret.address == 0 ? null : objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_NSMutableArray = objc.getClass("NSMutableArray");
late final _sel_arrayWithCapacity_ = objc.registerName("arrayWithCapacity:");
final _objc_msgSend_14hpxwa = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, int)
    >();

/// NSMutableArrayCreation
extension NSMutableArrayCreation on objc.NSMutableArray {
  /// initWithContentsOfFile:
  objc.NSMutableArray? initWithContentsOfFile(objc.NSString path) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSMutableArray.fromPointer($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.NSMutableArray? initWithContentsOfURL(objc.NSURL url) {
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSMutableArray.fromPointer($ret, retain: false, release: true);
  }

  /// arrayWithCapacity:
  static objc.NSMutableArray arrayWithCapacity(int numItems) {
    final $ret = _objc_msgSend_14hpxwa(_class_NSMutableArray, _sel_arrayWithCapacity_, numItems);
    return objc.NSMutableArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithContentsOfFile:
  static objc.NSMutableArray? arrayWithContentsOfFile(objc.NSString path) {
    final $ret = _objc_msgSend_1sotr3r(_class_NSMutableArray, _sel_arrayWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : objc.NSMutableArray.fromPointer($ret, retain: true, release: true);
  }

  /// arrayWithContentsOfURL:
  static objc.NSMutableArray? arrayWithContentsOfURL(objc.NSURL url) {
    final $ret = _objc_msgSend_1sotr3r(_class_NSMutableArray, _sel_arrayWithContentsOfURL_, url.ref.pointer);
    return $ret.address == 0 ? null : objc.NSMutableArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_applyDifference_ = objc.registerName("applyDifference:");

/// NSMutableArrayDiffing
extension NSMutableArrayDiffing on objc.NSMutableArray {
  /// applyDifference:
  void applyDifference(objc.NSOrderedCollectionDifference difference) {
    objc.checkOsVersionInternal(
      'NSMutableArray.applyDifference:',
      iOS: (false, (13, 0, 0)),
      macOS: (false, (10, 15, 0)),
    );
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_applyDifference_, difference.ref.pointer);
  }
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>`.
abstract final class ObjCBlock_ffiVoid_idNSSecureCoding_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> fromFunction(
    void Function(objc.NSSecureCoding?, objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSSecureCoding.fromPointer(arg0, retain: true, release: true),
        objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> listener(
    void Function(objc.NSSecureCoding?, objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSSecureCoding.fromPointer(arg0, retain: false, release: true),
        objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> blocking(
    void Function(objc.NSSecureCoding?, objc.NSError) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSSecureCoding.fromPointer(arg0, retain: false, release: true),
        objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSSecureCoding.fromPointer(arg0, retain: false, release: true),
        objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>(
      wrapper,
      retain: false,
      release: true,
    );
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>`.
extension ObjCBlock_ffiVoid_idNSSecureCoding_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> {
  void call(objc.NSSecureCoding? arg0, objc.NSError arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1.ref.pointer);
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>, ffi.Pointer<objc.ObjCObjectImpl>, objc.NSDictionary)>`.
abstract final class ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObjectImpl_NSDictionary {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      objc.NSDictionary,
    )
  >
  fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.NSDictionary,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      objc.NSDictionary,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCBlockImpl> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.NSDictionary,
        )
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      objc.NSDictionary,
    )
  >
  fromFunction(
    void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      objc.ObjCObject,
      objc.NSDictionary,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Void Function(
          objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          objc.NSDictionary,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ) => fn(
            ObjCBlock_ffiVoid_idNSSecureCoding_NSError.fromPointer(arg0, retain: true, release: true),
            objc.ObjCObject(arg1, retain: true, release: true),
            objc.NSDictionary.fromPointer(arg2, retain: true, release: true),
          ),
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      objc.NSDictionary,
    )
  >
  listener(
    void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      objc.ObjCObject,
      objc.NSDictionary,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCBlockImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        ObjCBlock_ffiVoid_idNSSecureCoding_NSError.fromPointer(arg0, retain: false, release: true),
        objc.ObjCObject(arg1, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapListenerBlock_1b3bb6a(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.NSDictionary,
      )
    >(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      objc.NSDictionary,
    )
  >
  blocking(
    void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      objc.ObjCObject,
      objc.NSDictionary,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCBlockImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        ObjCBlock_ffiVoid_idNSSecureCoding_NSError.fromPointer(arg0, retain: false, release: true),
        objc.ObjCObject(arg1, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (
        ffi.Pointer<objc.ObjCBlockImpl> arg0,
        ffi.Pointer<objc.ObjCObjectImpl> arg1,
        ffi.Pointer<objc.ObjCObjectImpl> arg2,
      ) => fn(
        ObjCBlock_ffiVoid_idNSSecureCoding_NSError.fromPointer(arg0, retain: false, release: true),
        objc.ObjCObject(arg1, retain: false, release: true),
        objc.NSDictionary.fromPointer(arg2, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapBlockingBlock_1b3bb6a(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<
      ffi.Void Function(
        objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.NSDictionary,
      )
    >(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    (objc.getBlockClosure(block)
        as void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        ))(arg0, arg1, arg2);
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCBlockImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>, ffi.Pointer<objc.ObjCObjectImpl>, objc.NSDictionary)>`.
extension ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObjectImpl_NSDictionary$CallExtension
    on
        objc.ObjCBlock<
          ffi.Void Function(
            objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            objc.NSDictionary,
          )
        > {
  void call(
    objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> arg0,
    objc.ObjCObject arg1,
    objc.NSDictionary arg2,
  ) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCBlockImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0.ref.pointer, arg1.ref.pointer, arg2.ref.pointer);
}

late final _class_NSItemProvider = objc.getClass("NSItemProvider");
late final _sel_previewImageHandler = objc.registerName("previewImageHandler");
final _objc_msgSend_uwvaik = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCBlockImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
    >();
late final _sel_setPreviewImageHandler_ = objc.registerName("setPreviewImageHandler:");
final _objc_msgSend_f167m6 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCBlockImpl>)
    >();
late final _sel_loadPreviewImageWithOptions_completionHandler_ = objc.registerName(
  "loadPreviewImageWithOptions:completionHandler:",
);
final _objc_msgSend_o762yo = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// NSPreviewSupport
extension NSPreviewSupport on objc.NSItemProvider {
  /// loadPreviewImageWithOptions:completionHandler:
  void loadPreviewImageWithOptions(
    objc.NSDictionary options, {
    required objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)> completionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSItemProvider.loadPreviewImageWithOptions:completionHandler:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_o762yo(
      object$.ref.pointer,
      _sel_loadPreviewImageWithOptions_completionHandler_,
      options.ref.pointer,
      completionHandler.ref.pointer,
    );
  }

  /// previewImageHandler
  objc.ObjCBlock<
    ffi.Void Function(
      objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      objc.NSDictionary,
    )
  >?
  get previewImageHandler {
    objc.checkOsVersionInternal(
      'NSItemProvider.previewImageHandler',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    final $ret = _objc_msgSend_uwvaik(object$.ref.pointer, _sel_previewImageHandler);
    return $ret.address == 0
        ? null
        : ObjCBlock_ffiVoid_NSItemProviderCompletionHandler_objcObjCObjectImpl_NSDictionary.fromPointer(
            $ret,
            retain: true,
            release: true,
          );
  }

  /// setPreviewImageHandler:
  set previewImageHandler(
    objc.ObjCBlock<
      ffi.Void Function(
        objc.ObjCBlock<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>?, objc.NSError)>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        objc.NSDictionary,
      )
    >?
    value,
  ) {
    objc.checkOsVersionInternal(
      'NSItemProvider.setPreviewImageHandler:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    _objc_msgSend_f167m6(object$.ref.pointer, _sel_setPreviewImageHandler_, value?.ref.pointer ?? ffi.nullptr);
  }
}

late final _class_NSString = objc.getClass("NSString");
late final _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_ = objc.registerName(
  "stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:",
);
final _objc_msgSend_1q2ox4r = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
          ffi.Pointer<ffi.Bool>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        ffi.Pointer<ffi.Bool>,
      )
    >();

/// NSStringEncodingDetection
extension NSStringEncodingDetection on objc.NSString {
  /// stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:
  static int stringEncodingForData(
    objc.NSData data, {
    objc.NSDictionary? encodingOptions,
    required ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> convertedString,
    required ffi.Pointer<ffi.Bool> usedLossyConversion,
  }) {
    objc.checkOsVersionInternal(
      'NSString.stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:',
      iOS: (false, (8, 0, 0)),
      macOS: (false, (10, 10, 0)),
    );
    return _objc_msgSend_1q2ox4r(
      _class_NSString,
      _sel_stringEncodingForData_encodingOptions_convertedString_usedLossyConversion_,
      data.ref.pointer,
      encodingOptions?.ref.pointer ?? ffi.nullptr,
      convertedString,
      usedLossyConversion,
    );
  }
}

late final _sel_readableTypeIdentifiersForItemProvider = objc.registerName("readableTypeIdentifiersForItemProvider");

/// Construction methods for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
abstract final class ObjCBlock_NSArray_ffiVoid {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunctionPointer(
    ffi.Pointer<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>> ptr,
  ) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> fromFunction(
    objc.NSArray Function(ffi.Pointer<ffi.Void>) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0) => fn(arg0).ref.retainAndAutorelease(),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void> arg0)>>()
      .asFunction<ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>)>()(arg0);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
  ) => (objc.getBlockClosure(block) as ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<ffi.Void>))(arg0);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)>`.
extension ObjCBlock_NSArray_ffiVoid$CallExtension on objc.ObjCBlock<objc.NSArray Function(ffi.Pointer<ffi.Void>)> {
  objc.NSArray call(ffi.Pointer<ffi.Void> arg0) => objc.NSArray.fromPointer(
    ref.pointer.ref.invoke
        .cast<
          ffi.NativeFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl> block, ffi.Pointer<ffi.Void> arg0)
          >
        >()
        .asFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>)
        >()(ref.pointer, arg0),
    retain: true,
    release: true,
  );
}

late final _sel_objectWithItemProviderData_typeIdentifier_error_ = objc.registerName(
  "objectWithItemProviderData:typeIdentifier:error:",
);
final _objc_msgSend_1pnyuds = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>`.
abstract final class ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
    )
  >
  fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCObjectImpl> arg2,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    ffi.Pointer<objc.ObjCObjectImpl>? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
    )
  >
  fromFunction(
    Dartinstancetype? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSData,
      objc.NSString,
      ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        ffi.Pointer<objc.ObjCObjectImpl>? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSData,
          objc.NSString,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
          ) =>
              fn(
                arg0,
                objc.NSData.fromPointer(arg1, retain: true, release: true),
                objc.NSString.fromPointer(arg2, retain: true, release: true),
                arg3,
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static instancetype _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          instancetype Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCObjectImpl> arg2,
            ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
          )
        >
      >()
      .asFunction<
        instancetype Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
        )
      >()(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static instancetype _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCObjectImpl> arg2,
    ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
  ) =>
      (objc.getBlockClosure(block)
          as instancetype Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
          ))(arg0, arg1, arg2, arg3);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            instancetype Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Pointer<objc.ObjCObjectImpl>? Function(ffi.Pointer<ffi.Void>, objc.NSData, objc.NSString, ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>)>`.
extension ObjCBlock_instancetype_ffiVoid_NSData_NSString_NSError$CallExtension
    on
        objc.ObjCBlock<
          ffi.Pointer<objc.ObjCObjectImpl>? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSData,
            objc.NSString,
            ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
          )
        > {
  Dartinstancetype? call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSData arg1,
    objc.NSString arg2,
    ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                    ffi.Pointer<objc.ObjCObjectImpl> arg2,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3)
              .address ==
          0
      ? null
      : objc.ObjCObject(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  instancetype Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                    ffi.Pointer<objc.ObjCObjectImpl> arg2,
                    ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>> arg3,
                  )
                >
              >()
              .asFunction<
                instancetype Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<ffi.Pointer<objc.ObjCObjectImpl>>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer, arg3),
          retain: true,
          release: true,
        );
}

late final _sel_writableTypeIdentifiersForItemProvider = objc.registerName("writableTypeIdentifiersForItemProvider");
late final _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_ = objc.registerName(
  "itemProviderVisibilityForRepresentationWithTypeIdentifier:",
);
final _objc_msgSend_16fy0up = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Long Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObjectImpl>)
    >();

/// Construction methods for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
abstract final class ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    pointer,
    retain: retain,
    release: release,
  );

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> fromFunction(
    objc.NSItemProviderRepresentationVisibility Function(ffi.Pointer<ffi.Void>, objc.NSString) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) =>
          fn(arg0, objc.NSString.fromPointer(arg1, retain: true, release: true)).value,
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  static int _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)>>()
      .asFunction<int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
          >(_fnPtrTrampoline, 0)
          .cast();
  static int _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => (objc.getBlockClosure(block) as int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>))(
    arg0,
    arg1,
  );
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Long Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
          >(_closureTrampoline, 0)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)>`.
extension ObjCBlock_NSItemProviderRepresentationVisibility_ffiVoid_NSString$CallExtension
    on objc.ObjCBlock<ffi.Long Function(ffi.Pointer<ffi.Void>, objc.NSString)> {
  objc.NSItemProviderRepresentationVisibility call(ffi.Pointer<ffi.Void> arg0, objc.NSString arg1) =>
      objc.NSItemProviderRepresentationVisibility.fromValue(
        ref.pointer.ref.invoke
            .cast<
              ffi.NativeFunction<
                ffi.Long Function(
                  ffi.Pointer<objc.ObjCBlockImpl> block,
                  ffi.Pointer<ffi.Void> arg0,
                  ffi.Pointer<objc.ObjCObjectImpl> arg1,
                )
              >
            >()
            .asFunction<
              int Function(ffi.Pointer<objc.ObjCBlockImpl>, ffi.Pointer<ffi.Void>, ffi.Pointer<objc.ObjCObjectImpl>)
            >()(ref.pointer, arg0, arg1.ref.pointer),
      );
}

/// Construction methods for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
abstract final class ObjCBlock_ffiVoid_NSData_NSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromPointer(
    ffi.Pointer<objc.ObjCBlockImpl> pointer, {
    bool retain = false,
    bool release = false,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
      >
    >
    ptr,
  ) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newPointerBlock(_fnPtrCallable, ptr.cast()),
    retain: false,
    release: true,
  );

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> fromFunction(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) => objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(
    objc.newClosureBlock(
      _closureCallable,
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: true, release: true),
        arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: true, release: true),
      ),
      keepIsolateAlive,
    ),
    retain: false,
    release: true,
  );

  /// Creates a listener block from a Dart function.
  ///
  /// This is based on FFI's NativeCallable.listener, and has the same
  /// capabilities and limitations. This block can be invoked from any thread,
  /// but only supports void functions, and is not run synchronously. See
  /// NativeCallable.listener for more details.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> listener(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _listenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapListenerBlock_pfv6jd(raw);
    objc.objectRelease(raw.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  /// Creates a blocking block from a Dart function.
  ///
  /// This callback can be invoked from any native thread, and will block the
  /// caller until the callback is handled by the Dart isolate that created
  /// the block. Async functions are not supported.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC. If the owner isolate
  /// has shut down, and the block is invoked by native code, it may block
  /// indefinitely, or have other undefined behavior.
  static objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> blocking(
    void Function(objc.NSData?, objc.NSError?) fn, {
    bool keepIsolateAlive = true,
  }) {
    final raw = objc.newClosureBlock(
      _blockingCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final rawListener = objc.newClosureBlock(
      _blockingListenerCallable.nativeFunction.cast(),
      (ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1) => fn(
        arg0.address == 0 ? null : objc.NSData.fromPointer(arg0, retain: false, release: true),
        arg1.address == 0 ? null : objc.NSError.fromPointer(arg1, retain: false, release: true),
      ),
      keepIsolateAlive,
    );
    final wrapper = _SwiftSoupBindings_wrapBlockingBlock_pfv6jd(raw, rawListener, objc.objCContext);
    objc.objectRelease(raw.cast());
    objc.objectRelease(rawListener.cast());
    return objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>(wrapper, retain: false, release: true);
  }

  static void _listenerTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    (objc.getBlockClosure(block) as void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>))(
      arg0,
      arg1,
    );
    objc.objectRelease(block.cast());
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _listenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_listenerTrampoline)
        ..keepIsolateAlive = false;
  static void _blockingTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> waiter,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) {
    try {
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
    } catch (e) {
    } finally {
      objc.signalWaiter(waiter);
      objc.objectRelease(block.cast());
    }
  }

  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.isolateLocal(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static ffi.NativeCallable<
    ffi.Void Function(
      ffi.Pointer<objc.ObjCBlockImpl>,
      ffi.Pointer<ffi.Void>,
      ffi.Pointer<objc.ObjCObjectImpl>,
      ffi.Pointer<objc.ObjCObjectImpl>,
    )
  >
  _blockingListenerCallable =
      ffi.NativeCallable<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl>,
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCObjectImpl>,
          )
        >.listener(_blockingTrampoline)
        ..keepIsolateAlive = false;
  static void _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1)
        >
      >()
      .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>)>()(arg0, arg1);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static void _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<objc.ObjCObjectImpl> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
  ) =>
      (objc.getBlockClosure(block)
          as void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCObjectImpl>))(arg0, arg1);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Void Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCObjectImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>`.
extension ObjCBlock_ffiVoid_NSData_NSError$CallExtension
    on objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> {
  void call(objc.NSData? arg0, objc.NSError? arg1) => ref.pointer.ref.invoke
      .cast<
        ffi.NativeFunction<
          ffi.Void Function(
            ffi.Pointer<objc.ObjCBlockImpl> block,
            ffi.Pointer<objc.ObjCObjectImpl> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
          )
        >
      >()
      .asFunction<
        void Function(
          ffi.Pointer<objc.ObjCBlockImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >()(ref.pointer, arg0?.ref.pointer ?? ffi.nullptr, arg1?.ref.pointer ?? ffi.nullptr);
}

late final _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_ = objc.registerName(
  "loadDataWithTypeIdentifier:forItemProviderCompletionHandler:",
);
final _objc_msgSend_r0bo0s = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCBlockImpl>,
      )
    >();

/// Construction methods for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
abstract final class ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError {
  /// Returns a block that wraps the given raw block pointer.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  fromPointer(ffi.Pointer<objc.ObjCBlockImpl> pointer, {bool retain = false, bool release = false}) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(pointer, retain: retain, release: release);

  /// Creates a block from a C function pointer.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  fromFunctionPointer(
    ffi.Pointer<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void> arg0,
          ffi.Pointer<objc.ObjCObjectImpl> arg1,
          ffi.Pointer<objc.ObjCBlockImpl> arg2,
        )
      >
    >
    ptr,
  ) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(objc.newPointerBlock(_fnPtrCallable, ptr.cast()), retain: false, release: true);

  /// Creates a block from a Dart function.
  ///
  /// This block must be invoked by native code running on the same thread as
  /// the isolate that registered it. Invoking the block on the wrong thread
  /// will result in a crash.
  ///
  /// If `keepIsolateAlive` is true, this block will keep this isolate alive
  /// until it is garbage collected by both Dart and ObjC.
  static objc.ObjCBlock<
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
  >
  fromFunction(
    objc.NSProgress? Function(
      ffi.Pointer<ffi.Void>,
      objc.NSString,
      objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
    )
    fn, {
    bool keepIsolateAlive = true,
  }) =>
      objc.ObjCBlock<
        objc.NSProgress? Function(
          ffi.Pointer<ffi.Void>,
          objc.NSString,
          objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
        )
      >(
        objc.newClosureBlock(
          _closureCallable,
          (ffi.Pointer<ffi.Void> arg0, ffi.Pointer<objc.ObjCObjectImpl> arg1, ffi.Pointer<objc.ObjCBlockImpl> arg2) =>
              fn(
                arg0,
                objc.NSString.fromPointer(arg1, retain: true, release: true),
                ObjCBlock_ffiVoid_NSData_NSError.fromPointer(arg2, retain: true, release: true),
              )?.ref.retainAndAutorelease() ??
              ffi.nullptr,
          keepIsolateAlive,
        ),
        retain: false,
        release: true,
      );

  static ffi.Pointer<objc.ObjCObjectImpl> _fnPtrTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCBlockImpl> arg2,
  ) => block.ref.target
      .cast<
        ffi.NativeFunction<
          ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void> arg0,
            ffi.Pointer<objc.ObjCObjectImpl> arg1,
            ffi.Pointer<objc.ObjCBlockImpl> arg2,
          )
        >
      >()
      .asFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCBlockImpl>,
        )
      >()(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _fnPtrCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_fnPtrTrampoline)
          .cast();
  static ffi.Pointer<objc.ObjCObjectImpl> _closureTrampoline(
    ffi.Pointer<objc.ObjCBlockImpl> block,
    ffi.Pointer<ffi.Void> arg0,
    ffi.Pointer<objc.ObjCObjectImpl> arg1,
    ffi.Pointer<objc.ObjCBlockImpl> arg2,
  ) =>
      (objc.getBlockClosure(block)
          as ffi.Pointer<objc.ObjCObjectImpl> Function(
            ffi.Pointer<ffi.Void>,
            ffi.Pointer<objc.ObjCObjectImpl>,
            ffi.Pointer<objc.ObjCBlockImpl>,
          ))(arg0, arg1, arg2);
  static ffi.Pointer<ffi.Void> _closureCallable =
      ffi.Pointer.fromFunction<
            ffi.Pointer<objc.ObjCObjectImpl> Function(
              ffi.Pointer<objc.ObjCBlockImpl>,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<objc.ObjCObjectImpl>,
              ffi.Pointer<objc.ObjCBlockImpl>,
            )
          >(_closureTrampoline)
          .cast();
}

/// Call operator for `objc.ObjCBlock<objc.NSProgress? Function(ffi.Pointer<ffi.Void>, objc.NSString, objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>)>`.
extension ObjCBlock_NSProgress_ffiVoid_NSString_ffiVoidNSDataNSError$CallExtension
    on
        objc.ObjCBlock<
          objc.NSProgress? Function(
            ffi.Pointer<ffi.Void>,
            objc.NSString,
            objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)>,
          )
        > {
  objc.NSProgress? call(
    ffi.Pointer<ffi.Void> arg0,
    objc.NSString arg1,
    objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> arg2,
  ) =>
      ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer)
              .address ==
          0
      ? null
      : objc.NSProgress.fromPointer(
          ref.pointer.ref.invoke
              .cast<
                ffi.NativeFunction<
                  ffi.Pointer<objc.ObjCObjectImpl> Function(
                    ffi.Pointer<objc.ObjCBlockImpl> block,
                    ffi.Pointer<ffi.Void> arg0,
                    ffi.Pointer<objc.ObjCObjectImpl> arg1,
                    ffi.Pointer<objc.ObjCBlockImpl> arg2,
                  )
                >
              >()
              .asFunction<
                ffi.Pointer<objc.ObjCObjectImpl> Function(
                  ffi.Pointer<objc.ObjCBlockImpl>,
                  ffi.Pointer<ffi.Void>,
                  ffi.Pointer<objc.ObjCObjectImpl>,
                  ffi.Pointer<objc.ObjCBlockImpl>,
                )
              >()(ref.pointer, arg0, arg1.ref.pointer, arg2.ref.pointer),
          retain: true,
          release: true,
        );
}

/// NSItemProvider
extension NSItemProvider on objc.NSString {
  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  objc.NSItemProviderRepresentationVisibility itemProviderVisibilityForRepresentationWithTypeIdentifier(
    objc.NSString typeIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(
      object$.ref.pointer,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
    )) {
      throw objc.UnimplementedOptionalMethodException(
        'NSString',
        'itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      );
    }
    final $ret = _objc_msgSend_16fy0up(
      object$.ref.pointer,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
    return objc.NSItemProviderRepresentationVisibility.fromValue($ret);
  }

  /// loadDataWithTypeIdentifier:forItemProviderCompletionHandler:
  objc.NSProgress? loadDataWithTypeIdentifier(
    objc.NSString typeIdentifier, {
    required objc.ObjCBlock<ffi.Void Function(objc.NSData?, objc.NSError?)> forItemProviderCompletionHandler,
  }) {
    objc.checkOsVersionInternal(
      'NSString.loadDataWithTypeIdentifier:forItemProviderCompletionHandler:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_r0bo0s(
      object$.ref.pointer,
      _sel_loadDataWithTypeIdentifier_forItemProviderCompletionHandler_,
      typeIdentifier.ref.pointer,
      forItemProviderCompletionHandler.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.NSProgress.fromPointer($ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  objc.NSArray get writableTypeIdentifiersForItemProvider {
    objc.checkOsVersionInternal(
      'NSString.writableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider)) {
      throw objc.UnimplementedOptionalMethodException('NSString', 'writableTypeIdentifiersForItemProvider');
    }
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// itemProviderVisibilityForRepresentationWithTypeIdentifier:
  static objc.NSItemProviderRepresentationVisibility itemProviderVisibilityForRepresentationWithTypeIdentifier$1(
    objc.NSString typeIdentifier,
  ) {
    objc.checkOsVersionInternal(
      'NSString.itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    if (!objc.respondsToSelector(_class_NSString, _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_)) {
      throw objc.UnimplementedOptionalMethodException(
        'NSString',
        'itemProviderVisibilityForRepresentationWithTypeIdentifier:',
      );
    }
    final $ret = _objc_msgSend_16fy0up(
      _class_NSString,
      _sel_itemProviderVisibilityForRepresentationWithTypeIdentifier_,
      typeIdentifier.ref.pointer,
    );
    return objc.NSItemProviderRepresentationVisibility.fromValue($ret);
  }

  /// objectWithItemProviderData:typeIdentifier:error:
  static objc.NSString? objectWithItemProviderData(objc.NSData data, {required objc.NSString typeIdentifier}) {
    objc.checkOsVersionInternal(
      'NSString.objectWithItemProviderData:typeIdentifier:error:',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $err = pkg_ffi.calloc<ffi.Pointer<objc.ObjCObjectImpl>>();
    try {
      final $ret = _objc_msgSend_1pnyuds(
        _class_NSString,
        _sel_objectWithItemProviderData_typeIdentifier_error_,
        data.ref.pointer,
        typeIdentifier.ref.pointer,
        $err,
      );
      objc.NSErrorException.checkErrorPointer($err.value);
      return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
    } finally {
      pkg_ffi.calloc.free($err);
    }
  }

  /// readableTypeIdentifiersForItemProvider
  static objc.NSArray getReadableTypeIdentifiersForItemProvider() {
    objc.checkOsVersionInternal(
      'NSString.readableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_readableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// writableTypeIdentifiersForItemProvider
  static objc.NSArray getWritableTypeIdentifiersForItemProvider$1() {
    objc.checkOsVersionInternal(
      'NSString.writableTypeIdentifiersForItemProvider',
      iOS: (false, (11, 0, 0)),
      macOS: (false, (10, 13, 0)),
    );
    final $ret = _objc_msgSend_151sglz(_class_NSString, _sel_writableTypeIdentifiersForItemProvider);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }
}

late final _class_NSMutableString = objc.getClass("NSMutableString");
late final _sel_insertString_atIndex_ = objc.registerName("insertString:atIndex:");
final _objc_msgSend_djsa9o = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
      )
    >();
late final _sel_deleteCharactersInRange_ = objc.registerName("deleteCharactersInRange:");
final _objc_msgSend_1e3pm0z = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, objc.NSRange)
      >
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, objc.NSRange)>();
late final _sel_appendString_ = objc.registerName("appendString:");
late final _sel_appendFormat_ = objc.registerName("appendFormat:");
late final _sel_setString_ = objc.registerName("setString:");
late final _sel_replaceOccurrencesOfString_withString_options_range_ = objc.registerName(
  "replaceOccurrencesOfString:withString:options:range:",
);
final _objc_msgSend_1upeo1d = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.UnsignedLong Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.UnsignedLong,
          objc.NSRange,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        int,
        objc.NSRange,
      )
    >();
late final _sel_applyTransform_reverse_range_updatedRange_ = objc.registerName(
  "applyTransform:reverse:range:updatedRange:",
);
final _objc_msgSend_zy00wz = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Bool,
          objc.NSRange,
          ffi.Pointer<objc.NSRange>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        bool,
        objc.NSRange,
        ffi.Pointer<objc.NSRange>,
      )
    >();
late final _sel_initWithCapacity_ = objc.registerName("initWithCapacity:");
late final _sel_stringWithCapacity_ = objc.registerName("stringWithCapacity:");

/// NSMutableStringExtensionMethods
extension NSMutableStringExtensionMethods on objc.NSMutableString {
  /// appendFormat:
  void appendFormat(objc.NSString format) {
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_appendFormat_, format.ref.pointer);
  }

  /// appendString:
  void appendString(objc.NSString aString) {
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_appendString_, aString.ref.pointer);
  }

  /// applyTransform:reverse:range:updatedRange:
  bool applyTransform(
    objc.NSString transform, {
    required bool reverse,
    required objc.NSRange range,
    required ffi.Pointer<objc.NSRange> updatedRange,
  }) {
    objc.checkOsVersionInternal(
      'NSMutableString.applyTransform:reverse:range:updatedRange:',
      iOS: (false, (9, 0, 0)),
      macOS: (false, (10, 11, 0)),
    );
    return _objc_msgSend_zy00wz(
      object$.ref.pointer,
      _sel_applyTransform_reverse_range_updatedRange_,
      transform.ref.pointer,
      reverse,
      range,
      updatedRange,
    );
  }

  /// deleteCharactersInRange:
  void deleteCharactersInRange(objc.NSRange range) {
    _objc_msgSend_1e3pm0z(object$.ref.pointer, _sel_deleteCharactersInRange_, range);
  }

  /// initWithCapacity:
  objc.NSMutableString initWithCapacity(int capacity) {
    final $ret = _objc_msgSend_14hpxwa(object$.ref.retainAndReturnPointer(), _sel_initWithCapacity_, capacity);
    return objc.NSMutableString.fromPointer($ret, retain: false, release: true);
  }

  /// insertString:atIndex:
  void insertString(objc.NSString aString, {required int atIndex}) {
    _objc_msgSend_djsa9o(object$.ref.pointer, _sel_insertString_atIndex_, aString.ref.pointer, atIndex);
  }

  /// replaceOccurrencesOfString:withString:options:range:
  int replaceOccurrencesOfString(
    objc.NSString target, {
    required objc.NSString withString,
    required int options,
    required objc.NSRange range,
  }) {
    return _objc_msgSend_1upeo1d(
      object$.ref.pointer,
      _sel_replaceOccurrencesOfString_withString_options_range_,
      target.ref.pointer,
      withString.ref.pointer,
      options,
      range,
    );
  }

  /// setString:
  void setString(objc.NSString aString) {
    _objc_msgSend_xtuoz7(object$.ref.pointer, _sel_setString_, aString.ref.pointer);
  }

  /// stringWithCapacity:
  static objc.NSMutableString stringWithCapacity(int capacity) {
    final $ret = _objc_msgSend_14hpxwa(_class_NSMutableString, _sel_stringWithCapacity_, capacity);
    return objc.NSMutableString.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_propertyList = objc.registerName("propertyList");
late final _sel_propertyListFromStringsFileFormat = objc.registerName("propertyListFromStringsFileFormat");

/// NSExtendedStringPropertyListParsing
extension NSExtendedStringPropertyListParsing on objc.NSString {
  /// propertyList
  objc.ObjCObject propertyList() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_propertyList);
    return objc.ObjCObject($ret, retain: true, release: true);
  }

  /// propertyListFromStringsFileFormat
  objc.NSDictionary? propertyListFromStringsFileFormat() {
    final $ret = _objc_msgSend_151sglz(object$.ref.pointer, _sel_propertyListFromStringsFileFormat);
    return $ret.address == 0 ? null : objc.NSDictionary.fromPointer($ret, retain: true, release: true);
  }
}

late final _sel_cString = objc.registerName("cString");
final _objc_msgSend_1fuqfwb = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)
      >
    >()
    .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_lossyCString = objc.registerName("lossyCString");
late final _sel_cStringLength = objc.registerName("cStringLength");
final _objc_msgSend_xw2lbc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.UnsignedLong Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>
    >()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>)>();
late final _sel_getCString_ = objc.registerName("getCString:");
final _objc_msgSend_1r7ue5f = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>)
    >();
late final _sel_getCString_maxLength_ = objc.registerName("getCString:maxLength:");
final _objc_msgSend_1h3mito = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.Char>, int)
    >();
late final _sel_getCString_maxLength_range_remainingRange_ = objc.registerName(
  "getCString:maxLength:range:remainingRange:",
);
final _objc_msgSend_3gpdva = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.UnsignedLong,
          objc.NSRange,
          ffi.Pointer<objc.NSRange>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        int,
        objc.NSRange,
        ffi.Pointer<objc.NSRange>,
      )
    >();
late final _sel_stringWithContentsOfFile_ = objc.registerName("stringWithContentsOfFile:");
late final _sel_stringWithContentsOfURL_ = objc.registerName("stringWithContentsOfURL:");
late final _sel_initWithCStringNoCopy_length_freeWhenDone_ = objc.registerName(
  "initWithCStringNoCopy:length:freeWhenDone:",
);
final _objc_msgSend_1ojrli4 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.UnsignedLong,
          ffi.Bool,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        int,
        bool,
      )
    >();
late final _sel_initWithCString_length_ = objc.registerName("initWithCString:length:");
final _objc_msgSend_erqryg = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
          ffi.UnsignedLong,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
        int,
      )
    >();
late final _sel_initWithCString_ = objc.registerName("initWithCString:");
final _objc_msgSend_56zxyn = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.Char>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<ffi.Char>,
      )
    >();
late final _sel_stringWithCString_length_ = objc.registerName("stringWithCString:length:");
late final _sel_stringWithCString_ = objc.registerName("stringWithCString:");
late final _sel_getCharacters_ = objc.registerName("getCharacters:");
final _objc_msgSend_g3kdhc = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<ffi.UnsignedShort>,
        )
      >
    >()
    .asFunction<
      void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<ffi.UnsignedShort>)
    >();

/// NSStringDeprecated
extension NSStringDeprecated on objc.NSString {
  /// cString
  ffi.Pointer<ffi.Char> cString() {
    objc.checkOsVersionInternal('NSString.cString', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_cString);
  }

  /// cStringLength
  int cStringLength() {
    objc.checkOsVersionInternal('NSString.cStringLength', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_xw2lbc(object$.ref.pointer, _sel_cStringLength);
  }

  /// getCString:
  void getCString(ffi.Pointer<ffi.Char> bytes) {
    objc.checkOsVersionInternal('NSString.getCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1r7ue5f(object$.ref.pointer, _sel_getCString_, bytes);
  }

  /// getCString:maxLength:
  void getCString$1(ffi.Pointer<ffi.Char> bytes, {required int maxLength}) {
    objc.checkOsVersionInternal('NSString.getCString:maxLength:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    _objc_msgSend_1h3mito(object$.ref.pointer, _sel_getCString_maxLength_, bytes, maxLength);
  }

  /// getCString:maxLength:range:remainingRange:
  void getCString$2(
    ffi.Pointer<ffi.Char> bytes, {
    required int maxLength,
    required objc.NSRange range,
    required ffi.Pointer<objc.NSRange> remainingRange,
  }) {
    objc.checkOsVersionInternal(
      'NSString.getCString:maxLength:range:remainingRange:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    _objc_msgSend_3gpdva(
      object$.ref.pointer,
      _sel_getCString_maxLength_range_remainingRange_,
      bytes,
      maxLength,
      range,
      remainingRange,
    );
  }

  /// getCharacters:
  void getCharacters(ffi.Pointer<ffi.UnsignedShort> buffer) {
    _objc_msgSend_g3kdhc(object$.ref.pointer, _sel_getCharacters_, buffer);
  }

  /// initWithCString:
  objc.ObjCObject? initWithCString(ffi.Pointer<ffi.Char> bytes) {
    objc.checkOsVersionInternal('NSString.initWithCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_56zxyn(object$.ref.retainAndReturnPointer(), _sel_initWithCString_, bytes);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// initWithCString:length:
  objc.ObjCObject? initWithCString$1(ffi.Pointer<ffi.Char> bytes, {required int length}) {
    objc.checkOsVersionInternal(
      'NSString.initWithCString:length:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_erqryg(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCString_length_,
      bytes,
      length,
    );
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// initWithCStringNoCopy:length:freeWhenDone:
  objc.ObjCObject? initWithCStringNoCopy(
    ffi.Pointer<ffi.Char> bytes, {
    required int length,
    required bool freeWhenDone,
  }) {
    objc.checkOsVersionInternal(
      'NSString.initWithCStringNoCopy:length:freeWhenDone:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1ojrli4(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithCStringNoCopy_length_freeWhenDone_,
      bytes,
      length,
      freeWhenDone,
    );
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// initWithContentsOfFile:
  objc.ObjCObject? initWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal(
      'NSString.initWithContentsOfFile:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfFile_,
      path.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// initWithContentsOfURL:
  objc.ObjCObject? initWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal('NSString.initWithContentsOfURL:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_1sotr3r(
      object$.ref.retainAndReturnPointer(),
      _sel_initWithContentsOfURL_,
      url.ref.pointer,
    );
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: false, release: true);
  }

  /// lossyCString
  ffi.Pointer<ffi.Char> lossyCString() {
    objc.checkOsVersionInternal('NSString.lossyCString', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1fuqfwb(object$.ref.pointer, _sel_lossyCString);
  }

  /// writeToFile:atomically:
  bool writeToFile(objc.NSString path, {required bool atomically}) {
    objc.checkOsVersionInternal(
      'NSString.writeToFile:atomically:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToFile_atomically_, path.ref.pointer, atomically);
  }

  /// writeToURL:atomically:
  bool writeToURL(objc.NSURL url, {required bool atomically}) {
    objc.checkOsVersionInternal('NSString.writeToURL:atomically:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    return _objc_msgSend_1iyq28l(object$.ref.pointer, _sel_writeToURL_atomically_, url.ref.pointer, atomically);
  }

  /// stringWithCString:
  static objc.ObjCObject? stringWithCString(ffi.Pointer<ffi.Char> bytes) {
    objc.checkOsVersionInternal('NSString.stringWithCString:', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_56zxyn(_class_NSString, _sel_stringWithCString_, bytes);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// stringWithCString:length:
  static objc.ObjCObject? stringWithCString$1(ffi.Pointer<ffi.Char> bytes, {required int length}) {
    objc.checkOsVersionInternal(
      'NSString.stringWithCString:length:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_erqryg(_class_NSString, _sel_stringWithCString_length_, bytes, length);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// stringWithContentsOfFile:
  static objc.ObjCObject? stringWithContentsOfFile(objc.NSString path) {
    objc.checkOsVersionInternal(
      'NSString.stringWithContentsOfFile:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_stringWithContentsOfFile_, path.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }

  /// stringWithContentsOfURL:
  static objc.ObjCObject? stringWithContentsOfURL(objc.NSURL url) {
    objc.checkOsVersionInternal(
      'NSString.stringWithContentsOfURL:',
      iOS: (false, (2, 0, 0)),
      macOS: (false, (10, 0, 0)),
    );
    final $ret = _objc_msgSend_1sotr3r(_class_NSString, _sel_stringWithContentsOfURL_, url.ref.pointer);
    return $ret.address == 0 ? null : objc.ObjCObject($ret, retain: true, release: true);
  }
}

late final _class_SwiftSoupBridge = objc.getClass("SwiftSoupWrapper.SwiftSoupBridge");
late final _sel_isKindOfClass_ = objc.registerName("isKindOfClass:");
late final _sel_parse_baseUri_ = objc.registerName("parse:baseUri:");
final _objc_msgSend_b7msfs = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int32 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_parseFragment_baseUri_ = objc.registerName("parseFragment:baseUri:");
late final _sel_select_selector_ = objc.registerName("select:selector:");
final _objc_msgSend_q7h7n7 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int32 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      int Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_selectFirst_selector_ = objc.registerName("selectFirst:selector:");
late final _sel_attr_key_ = objc.registerName("attr:key:");
final _objc_msgSend_hr54ec = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_hasAttr_key_ = objc.registerName("hasAttr:key:");
final _objc_msgSend_py4kgm = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Bool Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      bool Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_setAttr_key_value_ = objc.registerName("setAttr:key:value:");
final _objc_msgSend_1my652e = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int32,
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_removeAttr_key_ = objc.registerName("removeAttr:key:");
final _objc_msgSend_lof6g0 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Void Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int32,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      void Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        int,
        ffi.Pointer<objc.ObjCObjectImpl>,
      )
    >();
late final _sel_text_ = objc.registerName("text:");
final _objc_msgSend_aclumu = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Int32,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, int)
    >();
late final _sel_ownText_ = objc.registerName("ownText:");
late final _sel_innerHtml_ = objc.registerName("innerHtml:");
late final _sel_outerHtml_ = objc.registerName("outerHtml:");
late final _sel_setText_text_ = objc.registerName("setText:text:");
late final _sel_setHtml_html_ = objc.registerName("setHtml:html:");
late final _sel_data_ = objc.registerName("data:");
late final _sel_tagName_ = objc.registerName("tagName:");
late final _sel_elementId_ = objc.registerName("elementId:");
late final _sel_className_ = objc.registerName("className:");
late final _sel_hasClass_name_ = objc.registerName("hasClass:name:");
late final _sel_addClass_name_ = objc.registerName("addClass:name:");
late final _sel_removeClass_name_ = objc.registerName("removeClass:name:");
late final _sel_size_ = objc.registerName("size:");
final _objc_msgSend_zo3bvx = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Int32)
      >
    >()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_get_index_ = objc.registerName("get:index:");
final _objc_msgSend_1q0lyci = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int32 Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Int32, ffi.Int32)
      >
    >()
    .asFunction<int Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, int, int)>();
late final _sel_first_ = objc.registerName("first:");
late final _sel_last_ = objc.registerName("last:");
late final _sel_parent_ = objc.registerName("parent:");
late final _sel_children_ = objc.registerName("children:");
late final _sel_nextSibling_ = objc.registerName("nextSibling:");
late final _sel_prevSibling_ = objc.registerName("prevSibling:");
late final _sel_siblings_ = objc.registerName("siblings:");
late final _sel_remove_ = objc.registerName("remove:");
final _objc_msgSend_1bqef4y = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Int32)>
    >()
    .asFunction<void Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_prepend_html_ = objc.registerName("prepend:html:");
late final _sel_append_html_ = objc.registerName("append:html:");
late final _sel_nodeBaseUri_ = objc.registerName("nodeBaseUri:");
late final _sel_nodeAbsUrl_key_ = objc.registerName("nodeAbsUrl:key:");
late final _sel_setNodeBaseUri_value_ = objc.registerName("setNodeBaseUri:value:");
late final _sel_createElement_ = objc.registerName("createElement:");
final _objc_msgSend_fd28sq = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Int32 Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.ObjCObjectImpl>,
        )
      >
    >()
    .asFunction<
      int Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Pointer<objc.ObjCObjectImpl>)
    >();
late final _sel_createTextNode_ = objc.registerName("createTextNode:");
late final _sel_createElements_ = objc.registerName("createElements:");
late final _sel_nodeName_ = objc.registerName("nodeName:");
late final _sel_childNodeSize_ = objc.registerName("childNodeSize:");
late final _sel_childNode_index_ = objc.registerName("childNode:index:");
late final _sel_childNodeHandles_ = objc.registerName("childNodeHandles:");
late final _sel_isTextNode_ = objc.registerName("isTextNode:");
final _objc_msgSend_5q4tjk = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, ffi.Int32)>
    >()
    .asFunction<bool Function(ffi.Pointer<objc.ObjCObjectImpl>, ffi.Pointer<objc.ObjCSelector>, int)>();
late final _sel_parentNode_ = objc.registerName("parentNode:");
late final _sel_nodeOuterHtml_ = objc.registerName("nodeOuterHtml:");
late final _sel_removeNode_ = objc.registerName("removeNode:");
late final _sel_textNodeHandles_ = objc.registerName("textNodeHandles:");
late final _sel_textNodeText_ = objc.registerName("textNodeText:");
late final _sel_setTextNodeText_text_ = objc.registerName("setTextNodeText:text:");
late final _sel_textNodeWholeText_ = objc.registerName("textNodeWholeText:");
late final _sel_textNodeIsBlank_ = objc.registerName("textNodeIsBlank:");
late final _sel_free_ = objc.registerName("free:");
late final _sel_releaseAll = objc.registerName("releaseAll");
late final _sel_dispose = objc.registerName("dispose");
late final _sel_init = objc.registerName("init");
late final _sel_new = objc.registerName("new");
late final _sel_allocWithZone_ = objc.registerName("allocWithZone:");
final _objc_msgSend_1cwp428 = objc.msgSendPointer
    .cast<
      ffi.NativeFunction<
        ffi.Pointer<objc.ObjCObjectImpl> Function(
          ffi.Pointer<objc.ObjCObjectImpl>,
          ffi.Pointer<objc.ObjCSelector>,
          ffi.Pointer<objc.NSZone>,
        )
      >
    >()
    .asFunction<
      ffi.Pointer<objc.ObjCObjectImpl> Function(
        ffi.Pointer<objc.ObjCObjectImpl>,
        ffi.Pointer<objc.ObjCSelector>,
        ffi.Pointer<objc.NSZone>,
      )
    >();
late final _sel_alloc = objc.registerName("alloc");

/// SwiftSoupBridge
extension type SwiftSoupBridge._(objc.ObjCObject object$) implements objc.ObjCObject, objc.NSObject {
  /// Constructs a [SwiftSoupBridge] that points to the same underlying object as [other].
  SwiftSoupBridge.as(objc.ObjCObject other) : object$ = other {
    assert(isA(object$));
  }

  /// Constructs a [SwiftSoupBridge] that wraps the given raw object pointer.
  SwiftSoupBridge.fromPointer(ffi.Pointer<objc.ObjCObjectImpl> other, {bool retain = false, bool release = false})
    : object$ = objc.ObjCObject(other, retain: retain, release: release) {
    assert(isA(object$));
  }

  /// Returns whether [obj] is an instance of [SwiftSoupBridge].
  static bool isA(objc.ObjCObject obj) =>
      _objc_msgSend_19nvye5(obj.ref.pointer, _sel_isKindOfClass_, _class_SwiftSoupBridge);

  /// addClass:name:
  static void addClass(int handle, {required objc.NSString name}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_addClass_name_, handle, name.ref.pointer);
  }

  /// alloc
  static SwiftSoupBridge alloc() {
    final $ret = _objc_msgSend_151sglz(_class_SwiftSoupBridge, _sel_alloc);
    return SwiftSoupBridge.fromPointer($ret, retain: false, release: true);
  }

  /// allocWithZone:
  static SwiftSoupBridge allocWithZone(ffi.Pointer<objc.NSZone> zone) {
    final $ret = _objc_msgSend_1cwp428(_class_SwiftSoupBridge, _sel_allocWithZone_, zone);
    return SwiftSoupBridge.fromPointer($ret, retain: false, release: true);
  }

  /// append:html:
  static void append(int handle, {required objc.NSString html}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_append_html_, handle, html.ref.pointer);
  }

  /// attr:key:
  static objc.NSString? attr(int handle, {required objc.NSString key}) {
    final $ret = _objc_msgSend_hr54ec(_class_SwiftSoupBridge, _sel_attr_key_, handle, key.ref.pointer);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// childNode:index:
  static int childNode(int handle, {required int index}) {
    return _objc_msgSend_1q0lyci(_class_SwiftSoupBridge, _sel_childNode_index_, handle, index);
  }

  /// childNodeHandles:
  static objc.NSArray childNodeHandles(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_childNodeHandles_, handle);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// childNodeSize:
  static int childNodeSize(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_childNodeSize_, handle);
  }

  /// children:
  static int children(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_children_, handle);
  }

  /// className:
  static objc.NSString? className(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_className_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// createElement:
  static int createElement(objc.NSString tag) {
    return _objc_msgSend_fd28sq(_class_SwiftSoupBridge, _sel_createElement_, tag.ref.pointer);
  }

  /// createElements:
  static int createElements(objc.NSArray handles) {
    return _objc_msgSend_fd28sq(_class_SwiftSoupBridge, _sel_createElements_, handles.ref.pointer);
  }

  /// createTextNode:
  static int createTextNode(objc.NSString text) {
    return _objc_msgSend_fd28sq(_class_SwiftSoupBridge, _sel_createTextNode_, text.ref.pointer);
  }

  /// data:
  static objc.NSString? data(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_data_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// dispose
  static void dispose() {
    _objc_msgSend_1pl9qdv(_class_SwiftSoupBridge, _sel_dispose);
  }

  /// elementId:
  static objc.NSString? elementId(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_elementId_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// first:
  static int first(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_first_, handle);
  }

  /// free:
  static void free(int handle) {
    _objc_msgSend_1bqef4y(_class_SwiftSoupBridge, _sel_free_, handle);
  }

  /// get:index:
  static int get(int handle, {required int index}) {
    return _objc_msgSend_1q0lyci(_class_SwiftSoupBridge, _sel_get_index_, handle, index);
  }

  /// hasAttr:key:
  static bool hasAttr(int handle, {required objc.NSString key}) {
    return _objc_msgSend_py4kgm(_class_SwiftSoupBridge, _sel_hasAttr_key_, handle, key.ref.pointer);
  }

  /// hasClass:name:
  static bool hasClass(int handle, {required objc.NSString name}) {
    return _objc_msgSend_py4kgm(_class_SwiftSoupBridge, _sel_hasClass_name_, handle, name.ref.pointer);
  }

  /// innerHtml:
  static objc.NSString? innerHtml(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_innerHtml_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// isTextNode:
  static bool isTextNode(int handle) {
    return _objc_msgSend_5q4tjk(_class_SwiftSoupBridge, _sel_isTextNode_, handle);
  }

  /// last:
  static int last(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_last_, handle);
  }

  /// new
  static SwiftSoupBridge new$() {
    final $ret = _objc_msgSend_151sglz(_class_SwiftSoupBridge, _sel_new);
    return SwiftSoupBridge.fromPointer($ret, retain: false, release: true);
  }

  /// nextSibling:
  static int nextSibling(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_nextSibling_, handle);
  }

  /// nodeAbsUrl:key:
  static objc.NSString? nodeAbsUrl(int handle, {required objc.NSString key}) {
    final $ret = _objc_msgSend_hr54ec(_class_SwiftSoupBridge, _sel_nodeAbsUrl_key_, handle, key.ref.pointer);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// nodeBaseUri:
  static objc.NSString? nodeBaseUri(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_nodeBaseUri_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// nodeName:
  static objc.NSString? nodeName(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_nodeName_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// nodeOuterHtml:
  static objc.NSString? nodeOuterHtml(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_nodeOuterHtml_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// outerHtml:
  static objc.NSString? outerHtml(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_outerHtml_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// ownText:
  static objc.NSString? ownText(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_ownText_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// parent:
  static int parent(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_parent_, handle);
  }

  /// parentNode:
  static int parentNode(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_parentNode_, handle);
  }

  /// parse:baseUri:
  static int parse(objc.NSString html, {required objc.NSString baseUri}) {
    return _objc_msgSend_b7msfs(_class_SwiftSoupBridge, _sel_parse_baseUri_, html.ref.pointer, baseUri.ref.pointer);
  }

  /// parseFragment:baseUri:
  static int parseFragment(objc.NSString html, {required objc.NSString baseUri}) {
    return _objc_msgSend_b7msfs(
      _class_SwiftSoupBridge,
      _sel_parseFragment_baseUri_,
      html.ref.pointer,
      baseUri.ref.pointer,
    );
  }

  /// prepend:html:
  static void prepend(int handle, {required objc.NSString html}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_prepend_html_, handle, html.ref.pointer);
  }

  /// prevSibling:
  static int prevSibling(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_prevSibling_, handle);
  }

  /// releaseAll
  static void releaseAll() {
    _objc_msgSend_1pl9qdv(_class_SwiftSoupBridge, _sel_releaseAll);
  }

  /// remove:
  static void remove(int handle) {
    _objc_msgSend_1bqef4y(_class_SwiftSoupBridge, _sel_remove_, handle);
  }

  /// removeAttr:key:
  static void removeAttr(int handle, {required objc.NSString key}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_removeAttr_key_, handle, key.ref.pointer);
  }

  /// removeClass:name:
  static void removeClass(int handle, {required objc.NSString name}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_removeClass_name_, handle, name.ref.pointer);
  }

  /// removeNode:
  static void removeNode(int handle) {
    _objc_msgSend_1bqef4y(_class_SwiftSoupBridge, _sel_removeNode_, handle);
  }

  /// select:selector:
  static int select(int handle, {required objc.NSString selector}) {
    return _objc_msgSend_q7h7n7(_class_SwiftSoupBridge, _sel_select_selector_, handle, selector.ref.pointer);
  }

  /// selectFirst:selector:
  static int selectFirst(int handle, {required objc.NSString selector}) {
    return _objc_msgSend_q7h7n7(_class_SwiftSoupBridge, _sel_selectFirst_selector_, handle, selector.ref.pointer);
  }

  /// setAttr:key:value:
  static void setAttr(int handle, {required objc.NSString key, required objc.NSString value}) {
    _objc_msgSend_1my652e(_class_SwiftSoupBridge, _sel_setAttr_key_value_, handle, key.ref.pointer, value.ref.pointer);
  }

  /// setHtml:html:
  static void setHtml(int handle, {required objc.NSString html}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_setHtml_html_, handle, html.ref.pointer);
  }

  /// setNodeBaseUri:value:
  static void setNodeBaseUri(int handle, {required objc.NSString value}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_setNodeBaseUri_value_, handle, value.ref.pointer);
  }

  /// setText:text:
  static void setText(int handle, {required objc.NSString text}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_setText_text_, handle, text.ref.pointer);
  }

  /// setTextNodeText:text:
  static void setTextNodeText(int handle, {required objc.NSString text}) {
    _objc_msgSend_lof6g0(_class_SwiftSoupBridge, _sel_setTextNodeText_text_, handle, text.ref.pointer);
  }

  /// siblings:
  static int siblings(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_siblings_, handle);
  }

  /// size:
  static int size(int handle) {
    return _objc_msgSend_zo3bvx(_class_SwiftSoupBridge, _sel_size_, handle);
  }

  /// tagName:
  static objc.NSString? tagName(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_tagName_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// text:
  static objc.NSString? text(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_text_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// textNodeHandles:
  static objc.NSArray textNodeHandles(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_textNodeHandles_, handle);
    return objc.NSArray.fromPointer($ret, retain: true, release: true);
  }

  /// textNodeIsBlank:
  static bool textNodeIsBlank(int handle) {
    return _objc_msgSend_5q4tjk(_class_SwiftSoupBridge, _sel_textNodeIsBlank_, handle);
  }

  /// textNodeText:
  static objc.NSString? textNodeText(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_textNodeText_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// textNodeWholeText:
  static objc.NSString? textNodeWholeText(int handle) {
    final $ret = _objc_msgSend_aclumu(_class_SwiftSoupBridge, _sel_textNodeWholeText_, handle);
    return $ret.address == 0 ? null : objc.NSString.fromPointer($ret, retain: true, release: true);
  }

  /// Returns a new instance of SwiftSoupBridge constructed with the default `new` method.
  SwiftSoupBridge() : this.as(new$().object$);
}

extension SwiftSoupBridge$Methods on SwiftSoupBridge {
  /// init
  SwiftSoupBridge init() {
    objc.checkOsVersionInternal('SwiftSoupBridge.init', iOS: (false, (2, 0, 0)), macOS: (false, (10, 0, 0)));
    final $ret = _objc_msgSend_151sglz(object$.ref.retainAndReturnPointer(), _sel_init);
    return SwiftSoupBridge.fromPointer($ret, retain: false, release: true);
  }
}
