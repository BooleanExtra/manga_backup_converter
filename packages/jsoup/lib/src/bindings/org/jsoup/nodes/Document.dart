// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Element.dart' as element$_;

/// from: `org.jsoup.nodes.Document$OutputSettings$Syntax`
///
/// The output serialization syntax.
class Document$OutputSettings$Syntax extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Document$OutputSettings$Syntax> $type;

  @jni$_.internal
  Document$OutputSettings$Syntax.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/jsoup/nodes/Document$OutputSettings$Syntax',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document$OutputSettings$Syntax?> nullableType =
      $Document$OutputSettings$Syntax$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document$OutputSettings$Syntax> type = $Document$OutputSettings$Syntax$Type$();
  static final _id_html = _class.staticFieldId(
    r'html',
    r'Lorg/jsoup/nodes/Document$OutputSettings$Syntax;',
  );

  /// from: `static public final org.jsoup.nodes.Document$OutputSettings$Syntax html`
  /// The returned object must be released after use, by calling the [release] method.
  static Document$OutputSettings$Syntax get html => _id_html.get(_class, const $Document$OutputSettings$Syntax$Type$());

  static final _id_xml = _class.staticFieldId(
    r'xml',
    r'Lorg/jsoup/nodes/Document$OutputSettings$Syntax;',
  );

  /// from: `static public final org.jsoup.nodes.Document$OutputSettings$Syntax xml`
  /// The returned object must be released after use, by calling the [release] method.
  static Document$OutputSettings$Syntax get xml => _id_xml.get(_class, const $Document$OutputSettings$Syntax$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lorg/jsoup/nodes/Document$OutputSettings$Syntax;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document$OutputSettings$Syntax[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Document$OutputSettings$Syntax?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Document$OutputSettings$Syntax?>?>(
      const jni$_.$JArray$NullableType$<Document$OutputSettings$Syntax?>(
        $Document$OutputSettings$Syntax$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Document$OutputSettings$Syntax;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document$OutputSettings$Syntax valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static Document$OutputSettings$Syntax? valueOf(
    jni$_.JString? name,
  ) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<Document$OutputSettings$Syntax?>(
      const $Document$OutputSettings$Syntax$NullableType$(),
    );
  }
}

final class $Document$OutputSettings$Syntax$NullableType$ extends jni$_.JType<Document$OutputSettings$Syntax?> {
  @jni$_.internal
  const $Document$OutputSettings$Syntax$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document$OutputSettings$Syntax;';

  @jni$_.internal
  @core$_.override
  Document$OutputSettings$Syntax? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Document$OutputSettings$Syntax.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document$OutputSettings$Syntax?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$OutputSettings$Syntax$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$OutputSettings$Syntax$NullableType$) &&
        other is $Document$OutputSettings$Syntax$NullableType$;
  }
}

final class $Document$OutputSettings$Syntax$Type$ extends jni$_.JType<Document$OutputSettings$Syntax> {
  @jni$_.internal
  const $Document$OutputSettings$Syntax$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document$OutputSettings$Syntax;';

  @jni$_.internal
  @core$_.override
  Document$OutputSettings$Syntax fromReference(jni$_.JReference reference) =>
      Document$OutputSettings$Syntax.fromReference(
        reference,
      );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document$OutputSettings$Syntax?> get nullableType =>
      const $Document$OutputSettings$Syntax$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$OutputSettings$Syntax$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$OutputSettings$Syntax$Type$) &&
        other is $Document$OutputSettings$Syntax$Type$;
  }
}

/// from: `org.jsoup.nodes.Document$OutputSettings`
///
/// A Document's output settings control the form of the text() and html() methods.
class Document$OutputSettings extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Document$OutputSettings> $type;

  @jni$_.internal
  Document$OutputSettings.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/jsoup/nodes/Document$OutputSettings',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document$OutputSettings?> nullableType = $Document$OutputSettings$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document$OutputSettings> type = $Document$OutputSettings$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new OutputSettings object, with the default settings (UTF-8, HTML, EscapeMode.base, pretty-printing,
  ///         indent amount of 1).
  factory Document$OutputSettings() {
    return Document$OutputSettings.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference,
    );
  }

  static final _id_escapeMode = _class.instanceMethodId(
    r'escapeMode',
    r'()Lorg/jsoup/nodes/Entities$EscapeMode;',
  );

  static final _escapeMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Entities$EscapeMode escapeMode()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the document's current entity escape mode:
  ///         <ul>
  ///         <li><code>xhtml</code>, the minimal named entities in XHTML / XML</li>
  ///         <li><code>base</code>, which provides a limited set of named HTML
  ///         entities and escapes other characters as numbered entities for maximum compatibility</li>
  ///         <li><code>extended</code>,
  ///         which uses the complete set of HTML named entities.</li>
  ///         </ul>
  ///         The default escape mode is <code>base</code>.
  ///@return the document's current escape mode
  jni$_.JObject? escapeMode() {
    return _escapeMode(
      reference.pointer,
      _id_escapeMode as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_escapeMode$1 = _class.instanceMethodId(
    r'escapeMode',
    r'(Lorg/jsoup/nodes/Entities$EscapeMode;)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _escapeMode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings escapeMode(org.jsoup.nodes.Entities$EscapeMode escapeMode)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the document's escape mode, which determines how characters are escaped when the output character set
  /// does not support a given character:- using either a named or a numbered escape.
  ///@param escapeMode the new escape mode to use
  ///@return the document's output settings, for chaining
  Document$OutputSettings? escapeMode$1(
    jni$_.JObject? escapeMode,
  ) {
    final _$escapeMode = escapeMode?.reference ?? jni$_.jNullReference;
    return _escapeMode$1(
      reference.pointer,
      _id_escapeMode$1 as jni$_.JMethodIDPtr,
      _$escapeMode.pointer,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_charset = _class.instanceMethodId(
    r'charset',
    r'()Ljava/nio/charset/Charset;',
  );

  static final _charset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.charset.Charset charset()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the document's current output charset, which is used to control which characters are escaped when
  /// generating HTML (via the <code>html()</code> methods), and which are kept intact.
  ///
  /// Where possible (when parsing from a URL or File), the document's output charset is automatically set to the
  /// input charset. Otherwise, it defaults to UTF-8.
  ///@return the document's current charset.
  jni$_.JObject? charset() {
    return _charset(
      reference.pointer,
      _id_charset as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_charset$1 = _class.instanceMethodId(
    r'charset',
    r'(Ljava/nio/charset/Charset;)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _charset$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings charset(java.nio.charset.Charset charset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Update the document's output charset.
  ///@param charset the new charset to use.
  ///@return the document's output settings, for chaining
  Document$OutputSettings? charset$1(
    jni$_.JObject? charset,
  ) {
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return _charset$1(
      reference.pointer,
      _id_charset$1 as jni$_.JMethodIDPtr,
      _$charset.pointer,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_charset$2 = _class.instanceMethodId(
    r'charset',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _charset$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings charset(java.lang.String charset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Update the document's output charset.
  ///@param charset the new charset (by name) to use.
  ///@return the document's output settings, for chaining
  Document$OutputSettings? charset$2(
    jni$_.JString? charset,
  ) {
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    return _charset$2(
      reference.pointer,
      _id_charset$2 as jni$_.JMethodIDPtr,
      _$charset.pointer,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_syntax = _class.instanceMethodId(
    r'syntax',
    r'()Lorg/jsoup/nodes/Document$OutputSettings$Syntax;',
  );

  static final _syntax =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings$Syntax syntax()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the document's current output syntax.
  ///@return current syntax
  Document$OutputSettings$Syntax? syntax() {
    return _syntax(
      reference.pointer,
      _id_syntax as jni$_.JMethodIDPtr,
    ).object<Document$OutputSettings$Syntax?>(
      const $Document$OutputSettings$Syntax$NullableType$(),
    );
  }

  static final _id_syntax$1 = _class.instanceMethodId(
    r'syntax',
    r'(Lorg/jsoup/nodes/Document$OutputSettings$Syntax;)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _syntax$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings syntax(org.jsoup.nodes.Document$OutputSettings$Syntax syntax)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the document's output syntax. Either {@code html}, with empty tags and boolean attributes (etc), or
  /// {@code xml}, with self-closing tags.
  /// When set to Document.OutputSettings.Syntax\#xml xml, the \#escapeMode() escapeMode is
  /// automatically set to Entities.EscapeMode\#xhtml, but may be subsequently changed if desired.
  ///
  ///@param syntax serialization syntax
  ///@return the document's output settings, for chaining
  Document$OutputSettings? syntax$1(
    Document$OutputSettings$Syntax? syntax,
  ) {
    final _$syntax = syntax?.reference ?? jni$_.jNullReference;
    return _syntax$1(
      reference.pointer,
      _id_syntax$1 as jni$_.JMethodIDPtr,
      _$syntax.pointer,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_prettyPrint = _class.instanceMethodId(
    r'prettyPrint',
    r'()Z',
  );

  static final _prettyPrint =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean prettyPrint()`
  ///
  /// Get if pretty printing is enabled. Default is true. If disabled, the HTML output methods will not re-format
  /// the output, and the output will generally look like the input.
  ///@return if pretty printing is enabled.
  bool prettyPrint() {
    return _prettyPrint(
      reference.pointer,
      _id_prettyPrint as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_prettyPrint$1 = _class.instanceMethodId(
    r'prettyPrint',
    r'(Z)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _prettyPrint$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings prettyPrint(boolean pretty)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Enable or disable pretty printing.
  ///@param pretty new pretty print setting
  ///@return this, for chaining
  Document$OutputSettings? prettyPrint$1(
    bool pretty,
  ) {
    return _prettyPrint$1(
      reference.pointer,
      _id_prettyPrint$1 as jni$_.JMethodIDPtr,
      pretty ? 1 : 0,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_outline = _class.instanceMethodId(
    r'outline',
    r'()Z',
  );

  static final _outline =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean outline()`
  ///
  /// Get if outline mode is enabled. Default is false. If enabled, the HTML output methods will consider
  /// all tags as block.
  ///@return if outline mode is enabled.
  bool outline() {
    return _outline(
      reference.pointer,
      _id_outline as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_outline$1 = _class.instanceMethodId(
    r'outline',
    r'(Z)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _outline$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings outline(boolean outlineMode)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Enable or disable HTML outline mode.
  ///@param outlineMode new outline setting
  ///@return this, for chaining
  Document$OutputSettings? outline$1(
    bool outlineMode,
  ) {
    return _outline$1(
      reference.pointer,
      _id_outline$1 as jni$_.JMethodIDPtr,
      outlineMode ? 1 : 0,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_indentAmount = _class.instanceMethodId(
    r'indentAmount',
    r'()I',
  );

  static final _indentAmount =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int indentAmount()`
  ///
  /// Get the current tag indent amount, used when pretty printing.
  ///@return the current indent amount
  int indentAmount() {
    return _indentAmount(
      reference.pointer,
      _id_indentAmount as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_indentAmount$1 = _class.instanceMethodId(
    r'indentAmount',
    r'(I)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _indentAmount$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings indentAmount(int indentAmount)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the indent amount for pretty printing
  ///@param indentAmount number of spaces to use for indenting each level. Must be {@literal >=} 0.
  ///@return this, for chaining
  Document$OutputSettings? indentAmount$1(
    int indentAmount,
  ) {
    return _indentAmount$1(
      reference.pointer,
      _id_indentAmount$1 as jni$_.JMethodIDPtr,
      indentAmount,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_maxPaddingWidth = _class.instanceMethodId(
    r'maxPaddingWidth',
    r'()I',
  );

  static final _maxPaddingWidth =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int maxPaddingWidth()`
  ///
  /// Get the current max padding amount, used when pretty printing
  /// so very deeply nested nodes don't get insane padding amounts.
  ///@return the current indent amount
  int maxPaddingWidth() {
    return _maxPaddingWidth(
      reference.pointer,
      _id_maxPaddingWidth as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_maxPaddingWidth$1 = _class.instanceMethodId(
    r'maxPaddingWidth',
    r'(I)Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _maxPaddingWidth$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings maxPaddingWidth(int maxPaddingWidth)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the max padding amount for pretty printing so very deeply nested nodes don't get insane padding amounts.
  ///@param maxPaddingWidth number of spaces to use for indenting each level of nested nodes. Must be {@literal >=} -1.
  ///        Default is 30 and -1 means unlimited.
  ///@return this, for chaining
  Document$OutputSettings? maxPaddingWidth$1(
    int maxPaddingWidth,
  ) {
    return _maxPaddingWidth$1(
      reference.pointer,
      _id_maxPaddingWidth$1 as jni$_.JMethodIDPtr,
      maxPaddingWidth,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings clone()`
  /// The returned object must be released after use, by calling the [release] method.
  Document$OutputSettings? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }
}

final class $Document$OutputSettings$NullableType$ extends jni$_.JType<Document$OutputSettings?> {
  @jni$_.internal
  const $Document$OutputSettings$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document$OutputSettings;';

  @jni$_.internal
  @core$_.override
  Document$OutputSettings? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Document$OutputSettings.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document$OutputSettings?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$OutputSettings$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$OutputSettings$NullableType$) &&
        other is $Document$OutputSettings$NullableType$;
  }
}

final class $Document$OutputSettings$Type$ extends jni$_.JType<Document$OutputSettings> {
  @jni$_.internal
  const $Document$OutputSettings$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document$OutputSettings;';

  @jni$_.internal
  @core$_.override
  Document$OutputSettings fromReference(jni$_.JReference reference) => Document$OutputSettings.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document$OutputSettings?> get nullableType => const $Document$OutputSettings$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$OutputSettings$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$OutputSettings$Type$) && other is $Document$OutputSettings$Type$;
  }
}

/// from: `org.jsoup.nodes.Document$QuirksMode`
class Document$QuirksMode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Document$QuirksMode> $type;

  @jni$_.internal
  Document$QuirksMode.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(
    r'org/jsoup/nodes/Document$QuirksMode',
  );

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document$QuirksMode?> nullableType = $Document$QuirksMode$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document$QuirksMode> type = $Document$QuirksMode$Type$();
  static final _id_noQuirks = _class.staticFieldId(
    r'noQuirks',
    r'Lorg/jsoup/nodes/Document$QuirksMode;',
  );

  /// from: `static public final org.jsoup.nodes.Document$QuirksMode noQuirks`
  /// The returned object must be released after use, by calling the [release] method.
  static Document$QuirksMode get noQuirks => _id_noQuirks.get(_class, const $Document$QuirksMode$Type$());

  static final _id_quirks = _class.staticFieldId(
    r'quirks',
    r'Lorg/jsoup/nodes/Document$QuirksMode;',
  );

  /// from: `static public final org.jsoup.nodes.Document$QuirksMode quirks`
  /// The returned object must be released after use, by calling the [release] method.
  static Document$QuirksMode get quirks => _id_quirks.get(_class, const $Document$QuirksMode$Type$());

  static final _id_limitedQuirks = _class.staticFieldId(
    r'limitedQuirks',
    r'Lorg/jsoup/nodes/Document$QuirksMode;',
  );

  /// from: `static public final org.jsoup.nodes.Document$QuirksMode limitedQuirks`
  /// The returned object must be released after use, by calling the [release] method.
  static Document$QuirksMode get limitedQuirks => _id_limitedQuirks.get(_class, const $Document$QuirksMode$Type$());

  static final _id_values = _class.staticMethodId(
    r'values',
    r'()[Lorg/jsoup/nodes/Document$QuirksMode;',
  );

  static final _values =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document$QuirksMode[] values()`
  /// The returned object must be released after use, by calling the [release] method.
  static jni$_.JArray<Document$QuirksMode?>? values() {
    return _values(
      _class.reference.pointer,
      _id_values as jni$_.JMethodIDPtr,
    ).object<jni$_.JArray<Document$QuirksMode?>?>(
      const jni$_.$JArray$NullableType$<Document$QuirksMode?>(
        $Document$QuirksMode$NullableType$(),
      ),
    );
  }

  static final _id_valueOf = _class.staticMethodId(
    r'valueOf',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Document$QuirksMode;',
  );

  static final _valueOf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document$QuirksMode valueOf(java.lang.String name)`
  /// The returned object must be released after use, by calling the [release] method.
  static Document$QuirksMode? valueOf(
    jni$_.JString? name,
  ) {
    final _$name = name?.reference ?? jni$_.jNullReference;
    return _valueOf(
      _class.reference.pointer,
      _id_valueOf as jni$_.JMethodIDPtr,
      _$name.pointer,
    ).object<Document$QuirksMode?>(const $Document$QuirksMode$NullableType$());
  }
}

final class $Document$QuirksMode$NullableType$ extends jni$_.JType<Document$QuirksMode?> {
  @jni$_.internal
  const $Document$QuirksMode$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document$QuirksMode;';

  @jni$_.internal
  @core$_.override
  Document$QuirksMode? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Document$QuirksMode.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document$QuirksMode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$QuirksMode$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$QuirksMode$NullableType$) && other is $Document$QuirksMode$NullableType$;
  }
}

final class $Document$QuirksMode$Type$ extends jni$_.JType<Document$QuirksMode> {
  @jni$_.internal
  const $Document$QuirksMode$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document$QuirksMode;';

  @jni$_.internal
  @core$_.override
  Document$QuirksMode fromReference(jni$_.JReference reference) => Document$QuirksMode.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document$QuirksMode?> get nullableType => const $Document$QuirksMode$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Document$QuirksMode$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$QuirksMode$Type$) && other is $Document$QuirksMode$Type$;
  }
}

/// from: `org.jsoup.nodes.Document`
///
/// A HTML Document.
///@author Jonathan Hedley, jonathan@hedley.net
class Document extends element$_.Element {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Document> $type;

  @jni$_.internal
  Document.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/jsoup/nodes/Document');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document?> nullableType = $Document$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Document> type = $Document$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String namespace, java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new, empty Document, in the specified namespace.
  ///@param namespace the namespace of this Document's root node.
  ///@param baseUri base URI of document
  ///@see org.jsoup.Jsoup\#parse
  ///@see \#createShell
  factory Document(
    jni$_.JString? namespace,
    jni$_.JString? baseUri,
  ) {
    final _$namespace = namespace?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return Document.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$namespace.pointer,
        _$baseUri.pointer,
      ).reference,
    );
  }

  static final _id_new1 = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new, empty Document, in the HTML namespace.
  ///@param baseUri base URI of document
  ///@see org.jsoup.Jsoup\#parse
  ///@see \#Document(String namespace, String baseUri)
  factory Document.new1(
    jni$_.JString? baseUri,
  ) {
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return Document.fromReference(
      _new1(
        _class.reference.pointer,
        _id_new1 as jni$_.JMethodIDPtr,
        _$baseUri.pointer,
      ).reference,
    );
  }

  static final _id_createShell = _class.staticMethodId(
    r'createShell',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _createShell =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document createShell(java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a valid, empty shell of a document, suitable for adding more elements to.
  ///@param baseUri baseUri of document
  ///@return document with html, head, and body elements.
  static Document? createShell(
    jni$_.JString? baseUri,
  ) {
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return _createShell(
      _class.reference.pointer,
      _id_createShell as jni$_.JMethodIDPtr,
      _$baseUri.pointer,
    ).object<Document?>(const $Document$NullableType$());
  }

  static final _id_location = _class.instanceMethodId(
    r'location',
    r'()Ljava/lang/String;',
  );

  static final _location =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String location()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the URL this Document was parsed from. If the starting URL is a redirect,
  /// this will return the final URL from which the document was served from.
  /// Will return an empty string if the location is unknown (e.g. if parsed from a String).
  ///@return location
  jni$_.JString? location() {
    return _location(
      reference.pointer,
      _id_location as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_connection = _class.instanceMethodId(
    r'connection',
    r'()Lorg/jsoup/Connection;',
  );

  static final _connection =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.Connection connection()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the Connection (Request/Response) object that was used to fetch this document, if any; otherwise, a new
  ///     default Connection object. This can be used to continue a session, preserving settings and cookies, etc.
  ///@return the Connection (session) associated with this Document, or an empty one otherwise.
  ///@see Connection\#newRequest()
  jni$_.JObject? connection() {
    return _connection(
      reference.pointer,
      _id_connection as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_documentType = _class.instanceMethodId(
    r'documentType',
    r'()Lorg/jsoup/nodes/DocumentType;',
  );

  static final _documentType =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.DocumentType documentType()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns this Document's doctype.
  ///@return document type, or null if not set
  jni$_.JObject? documentType() {
    return _documentType(
      reference.pointer,
      _id_documentType as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_head = _class.instanceMethodId(
    r'head',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _head =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element head()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this document's {@code head} element.
  ///
  ///     As a side effect, if this Document does not already have an HTML structure, it will be created. If you do not want
  ///     that, use {@code \#selectFirst("head")} instead.
  ///@return {@code head} element.
  element$_.Element? head() {
    return _head(
      reference.pointer,
      _id_head as jni$_.JMethodIDPtr,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_body = _class.instanceMethodId(
    r'body',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _body =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element body()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this document's {@code <body>} or {@code <frameset>} element.
  ///
  ///     As a __side-effect__, if this Document does not already have an HTML structure, it will be created with a {@code
  ///    <body>} element. If you do not want that, use {@code \#selectFirst("body")} instead.
  ///@return {@code body} element for documents with a {@code <body>}, a new {@code <body>} element if the document
  ///     had no contents, or the outermost {@code <frameset> element} for frameset documents.
  element$_.Element? body() {
    return _body(
      reference.pointer,
      _id_body as jni$_.JMethodIDPtr,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_forms = _class.instanceMethodId(
    r'forms',
    r'()Ljava/util/List;',
  );

  static final _forms =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.FormElement> forms()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the {@code <form>} elements contained in this document.
  ///@return a List of FormElement objects, which will be empty if there are none.
  ///@see Elements\#forms()
  ///@see FormElement\#elements()
  ///@since 1.15.4
  jni$_.JList<jni$_.JObject?>? forms() {
    return _forms(
      reference.pointer,
      _id_forms as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_expectForm = _class.instanceMethodId(
    r'expectForm',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/FormElement;',
  );

  static final _expectForm =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.FormElement expectForm(java.lang.String cssQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Selects the first FormElement in this document that matches the query. If none match, throws an
  ///     IllegalArgumentException.
  ///@param cssQuery a Selector CSS query
  ///@return the first matching {@code <form>} element
  ///@throws IllegalArgumentException if no match is found
  ///@since 1.15.4
  jni$_.JObject? expectForm(
    jni$_.JString? cssQuery,
  ) {
    final _$cssQuery = cssQuery?.reference ?? jni$_.jNullReference;
    return _expectForm(
      reference.pointer,
      _id_expectForm as jni$_.JMethodIDPtr,
      _$cssQuery.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_title = _class.instanceMethodId(
    r'title',
    r'()Ljava/lang/String;',
  );

  static final _title =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String title()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the string contents of the document's {@code title} element.
  ///@return Trimmed title, or empty string if none set.
  jni$_.JString? title() {
    return _title(
      reference.pointer,
      _id_title as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_title$1 = _class.instanceMethodId(
    r'title',
    r'(Ljava/lang/String;)V',
  );

  static final _title$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void title(java.lang.String title)`
  ///
  /// Set the document's {@code title} element. Updates the existing element, or adds {@code title} to {@code head} if
  ///     not present
  ///@param title string to set as title
  void title$1(
    jni$_.JString? title,
  ) {
    final _$title = title?.reference ?? jni$_.jNullReference;
    _title$1(
      reference.pointer,
      _id_title$1 as jni$_.JMethodIDPtr,
      _$title.pointer,
    ).check();
  }

  static final _id_createElement = _class.instanceMethodId(
    r'createElement',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _createElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element createElement(java.lang.String tagName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new Element, with this document's base uri. Does not make the new element a child of this document.
  ///@param tagName element tag name (e.g. {@code a})
  ///@return new element
  element$_.Element? createElement(
    jni$_.JString? tagName,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    return _createElement(
      reference.pointer,
      _id_createElement as jni$_.JMethodIDPtr,
      _$tagName.pointer,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_outerHtml$1 = _class.instanceMethodId(
    r'outerHtml',
    r'()Ljava/lang/String;',
  );

  static final _outerHtml$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String outerHtml()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? outerHtml$1() {
    return _outerHtml$1(
      reference.pointer,
      _id_outerHtml$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_text1 = _class.instanceMethodId(
    r'text',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _text1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element text(java.lang.String text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the text of the {@code body} of this document. Any existing nodes within the body will be cleared.
  ///@param text un-encoded text
  ///@return this document
  element$_.Element? text1(
    jni$_.JString? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _text1(
      reference.pointer,
      _id_text1 as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_nodeName = _class.instanceMethodId(
    r'nodeName',
    r'()Ljava/lang/String;',
  );

  static final _nodeName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String nodeName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? nodeName() {
    return _nodeName(
      reference.pointer,
      _id_nodeName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_charset = _class.instanceMethodId(
    r'charset',
    r'(Ljava/nio/charset/Charset;)V',
  );

  static final _charset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void charset(java.nio.charset.Charset charset)`
  ///
  /// Sets the charset used in this document. This method is equivalent
  /// to OutputSettings\#charset(java.nio.charset.Charset) OutputSettings.charset(Charset) but in addition it updates the
  /// charset / encoding element within the document.
  ///
  /// This enables
  /// \#updateMetaCharsetElement(boolean) meta charset update.
  ///
  ///
  /// If there's no element with charset / encoding information yet it will
  /// be created. Obsolete charset / encoding definitions are removed!
  ///
  ///
  /// __Elements used:__
  ///
  ///
  /// <ul>
  /// <li>__Html:__ <i>&lt;meta charset="CHARSET"&gt;</i></li>
  /// <li>__Xml:__ <i>&lt;?xml version="1.0" encoding="CHARSET"&gt;</i></li>
  /// </ul>
  ///@param charset Charset
  ///@see \#updateMetaCharsetElement(boolean)
  ///@see OutputSettings\#charset(java.nio.charset.Charset)
  void charset(
    jni$_.JObject? charset,
  ) {
    final _$charset = charset?.reference ?? jni$_.jNullReference;
    _charset(
      reference.pointer,
      _id_charset as jni$_.JMethodIDPtr,
      _$charset.pointer,
    ).check();
  }

  static final _id_charset$1 = _class.instanceMethodId(
    r'charset',
    r'()Ljava/nio/charset/Charset;',
  );

  static final _charset$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.nio.charset.Charset charset()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns the charset used in this document. This method is equivalent
  /// to OutputSettings\#charset().
  ///@return Current Charset
  ///@see OutputSettings\#charset()
  jni$_.JObject? charset$1() {
    return _charset$1(
      reference.pointer,
      _id_charset$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_updateMetaCharsetElement = _class.instanceMethodId(
    r'updateMetaCharsetElement',
    r'(Z)V',
  );

  static final _updateMetaCharsetElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public void updateMetaCharsetElement(boolean update)`
  ///
  /// Sets whether the element with charset information in this document is
  /// updated on changes through \#charset(java.nio.charset.Charset) Document.charset(Charset) or not.
  ///
  /// If set to <tt>false</tt> <i>(default)</i> there are no elements
  /// modified.
  ///
  ///@param update If <tt>true</tt> the element updated on charset
  /// changes, <tt>false</tt> if not
  ///@see \#charset(java.nio.charset.Charset)
  void updateMetaCharsetElement(
    bool update,
  ) {
    _updateMetaCharsetElement(
      reference.pointer,
      _id_updateMetaCharsetElement as jni$_.JMethodIDPtr,
      update ? 1 : 0,
    ).check();
  }

  static final _id_updateMetaCharsetElement$1 = _class.instanceMethodId(
    r'updateMetaCharsetElement',
    r'()Z',
  );

  static final _updateMetaCharsetElement$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean updateMetaCharsetElement()`
  ///
  /// Returns whether the element with charset information in this document is
  /// updated on changes through \#charset(java.nio.charset.Charset) Document.charset(Charset) or not.
  ///@return Returns <tt>true</tt> if the element is updated on charset
  /// changes, <tt>false</tt> if not
  bool updateMetaCharsetElement$1() {
    return _updateMetaCharsetElement$1(
      reference.pointer,
      _id_updateMetaCharsetElement$1 as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_clone$2 = _class.instanceMethodId(
    r'clone',
    r'()Lorg/jsoup/nodes/Document;',
  );

  static final _clone$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Document clone()`
  /// The returned object must be released after use, by calling the [release] method.
  Document? clone$2() {
    return _clone$2(
      reference.pointer,
      _id_clone$2 as jni$_.JMethodIDPtr,
    ).object<Document?>(const $Document$NullableType$());
  }

  static final _id_shallowClone$2 = _class.instanceMethodId(
    r'shallowClone',
    r'()Lorg/jsoup/nodes/Document;',
  );

  static final _shallowClone$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Document shallowClone()`
  /// The returned object must be released after use, by calling the [release] method.
  Document? shallowClone$2() {
    return _shallowClone$2(
      reference.pointer,
      _id_shallowClone$2 as jni$_.JMethodIDPtr,
    ).object<Document?>(const $Document$NullableType$());
  }

  static final _id_outputSettings = _class.instanceMethodId(
    r'outputSettings',
    r'()Lorg/jsoup/nodes/Document$OutputSettings;',
  );

  static final _outputSettings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$OutputSettings outputSettings()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the document's current output settings.
  ///@return the document's current output settings.
  Document$OutputSettings? outputSettings() {
    return _outputSettings(
      reference.pointer,
      _id_outputSettings as jni$_.JMethodIDPtr,
    ).object<Document$OutputSettings?>(
      const $Document$OutputSettings$NullableType$(),
    );
  }

  static final _id_outputSettings$1 = _class.instanceMethodId(
    r'outputSettings',
    r'(Lorg/jsoup/nodes/Document$OutputSettings;)Lorg/jsoup/nodes/Document;',
  );

  static final _outputSettings$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document outputSettings(org.jsoup.nodes.Document$OutputSettings outputSettings)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the document's output settings.
  ///@param outputSettings new output settings.
  ///@return this document, for chaining.
  Document? outputSettings$1(
    Document$OutputSettings? outputSettings,
  ) {
    final _$outputSettings = outputSettings?.reference ?? jni$_.jNullReference;
    return _outputSettings$1(
      reference.pointer,
      _id_outputSettings$1 as jni$_.JMethodIDPtr,
      _$outputSettings.pointer,
    ).object<Document?>(const $Document$NullableType$());
  }

  static final _id_quirksMode = _class.instanceMethodId(
    r'quirksMode',
    r'()Lorg/jsoup/nodes/Document$QuirksMode;',
  );

  static final _quirksMode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Document$QuirksMode quirksMode()`
  /// The returned object must be released after use, by calling the [release] method.
  Document$QuirksMode? quirksMode() {
    return _quirksMode(
      reference.pointer,
      _id_quirksMode as jni$_.JMethodIDPtr,
    ).object<Document$QuirksMode?>(const $Document$QuirksMode$NullableType$());
  }

  static final _id_quirksMode$1 = _class.instanceMethodId(
    r'quirksMode',
    r'(Lorg/jsoup/nodes/Document$QuirksMode;)Lorg/jsoup/nodes/Document;',
  );

  static final _quirksMode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document quirksMode(org.jsoup.nodes.Document$QuirksMode quirksMode)`
  /// The returned object must be released after use, by calling the [release] method.
  Document? quirksMode$1(
    Document$QuirksMode? quirksMode,
  ) {
    final _$quirksMode = quirksMode?.reference ?? jni$_.jNullReference;
    return _quirksMode$1(
      reference.pointer,
      _id_quirksMode$1 as jni$_.JMethodIDPtr,
      _$quirksMode.pointer,
    ).object<Document?>(const $Document$NullableType$());
  }

  static final _id_parser = _class.instanceMethodId(
    r'parser',
    r'()Lorg/jsoup/parser/Parser;',
  );

  static final _parser =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.parser.Parser parser()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the parser that was used to parse this document.
  ///@return the parser
  jni$_.JObject? parser() {
    return _parser(
      reference.pointer,
      _id_parser as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_parser$1 = _class.instanceMethodId(
    r'parser',
    r'(Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;',
  );

  static final _parser$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document parser(org.jsoup.parser.Parser parser)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the parser used to create this document. This parser is then used when further parsing within this document
  /// is required.
  ///@param parser the configured parser to use when further parsing is required for this document.
  ///@return this document, for chaining.
  Document? parser$1(
    jni$_.JObject? parser,
  ) {
    final _$parser = parser?.reference ?? jni$_.jNullReference;
    return _parser$1(
      reference.pointer,
      _id_parser$1 as jni$_.JMethodIDPtr,
      _$parser.pointer,
    ).object<Document?>(const $Document$NullableType$());
  }

  static final _id_connection$1 = _class.instanceMethodId(
    r'connection',
    r'(Lorg/jsoup/Connection;)Lorg/jsoup/nodes/Document;',
  );

  static final _connection$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Document connection(org.jsoup.Connection connection)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the Connection used to fetch this document. This Connection is used as a session object when further requests are
  ///     made (e.g. when a form is submitted).
  ///@param connection to set
  ///@return this document, for chaining
  ///@see Connection\#newRequest()
  ///@since 1.14.1
  Document? connection$1(
    jni$_.JObject? connection,
  ) {
    final _$connection = connection?.reference ?? jni$_.jNullReference;
    return _connection$1(
      reference.pointer,
      _id_connection$1 as jni$_.JMethodIDPtr,
      _$connection.pointer,
    ).object<Document?>(const $Document$NullableType$());
  }
}

final class $Document$NullableType$ extends jni$_.JType<Document?> {
  @jni$_.internal
  const $Document$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document;';

  @jni$_.internal
  @core$_.override
  Document? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Document.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const element$_.$Element$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($Document$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$NullableType$) && other is $Document$NullableType$;
  }
}

final class $Document$Type$ extends jni$_.JType<Document> {
  @jni$_.internal
  const $Document$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Document;';

  @jni$_.internal
  @core$_.override
  Document fromReference(jni$_.JReference reference) => Document.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const element$_.$Element$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Document?> get nullableType => const $Document$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 3;

  @core$_.override
  int get hashCode => ($Document$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Document$Type$) && other is $Document$Type$;
  }
}
