// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'Document.dart' as document$_;

/// from: `org.jsoup.nodes.Node`
///
/// The base, abstract Node model. Element, Document, Comment, TextNode, et al.,
/// are instances of Node.
///@author Jonathan Hedley, jonathan@hedley.net
class Node extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Node> $type;

  @jni$_.internal
  Node.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/jsoup/nodes/Node');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Node?> nullableType = $Node$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Node> type = $Node$Type$();
  static final _id_nodeName = _class.instanceMethodId(
    r'nodeName',
    r'()Ljava/lang/String;',
  );

  static final _nodeName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String nodeName()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the node name of this node. Use for debugging purposes and not logic switching (for that, use instanceof).
  ///@return node name
  jni$_.JString? nodeName() {
    return _nodeName(
      reference.pointer,
      _id_nodeName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_normalName = _class.instanceMethodId(
    r'normalName',
    r'()Ljava/lang/String;',
  );

  static final _normalName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String normalName()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the normalized name of this node. For node types other than Element, this is the same as \#nodeName().
  ///     For an Element, will be the lower-cased tag name.
  ///@return normalized node name
  ///@since 1.15.4.
  jni$_.JString? normalName() {
    return _normalName(
      reference.pointer,
      _id_normalName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_nameIs = _class.instanceMethodId(
    r'nameIs',
    r'(Ljava/lang/String;)Z',
  );

  static final _nameIs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean nameIs(java.lang.String normalName)`
  ///
  /// Test if this node has the specified normalized name, in any namespace.
  ///@param normalName a normalized element name (e.g. {@code div}).
  ///@return true if the element's normal name matches exactly
  ///@since 1.17.2
  bool nameIs(
    jni$_.JString? normalName,
  ) {
    final _$normalName = normalName?.reference ?? jni$_.jNullReference;
    return _nameIs(
      reference.pointer,
      _id_nameIs as jni$_.JMethodIDPtr,
      _$normalName.pointer,
    ).boolean;
  }

  static final _id_parentNameIs = _class.instanceMethodId(
    r'parentNameIs',
    r'(Ljava/lang/String;)Z',
  );

  static final _parentNameIs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean parentNameIs(java.lang.String normalName)`
  ///
  /// Test if this node's parent has the specified normalized name.
  ///@param normalName a normalized name (e.g. {@code div}).
  ///@return true if the parent element's normal name matches exactly
  ///@since 1.17.2
  bool parentNameIs(
    jni$_.JString? normalName,
  ) {
    final _$normalName = normalName?.reference ?? jni$_.jNullReference;
    return _parentNameIs(
      reference.pointer,
      _id_parentNameIs as jni$_.JMethodIDPtr,
      _$normalName.pointer,
    ).boolean;
  }

  static final _id_parentElementIs = _class.instanceMethodId(
    r'parentElementIs',
    r'(Ljava/lang/String;Ljava/lang/String;)Z',
  );

  static final _parentElementIs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean parentElementIs(java.lang.String normalName, java.lang.String namespace)`
  ///
  /// Test if this node's parent is an Element with the specified normalized name and namespace.
  ///@param normalName a normalized element name (e.g. {@code div}).
  ///@param namespace the namespace
  ///@return true if the parent element's normal name matches exactly, and that element is in the specified namespace
  ///@since 1.17.2
  bool parentElementIs(
    jni$_.JString? normalName,
    jni$_.JString? namespace,
  ) {
    final _$normalName = normalName?.reference ?? jni$_.jNullReference;
    final _$namespace = namespace?.reference ?? jni$_.jNullReference;
    return _parentElementIs(
      reference.pointer,
      _id_parentElementIs as jni$_.JMethodIDPtr,
      _$normalName.pointer,
      _$namespace.pointer,
    ).boolean;
  }

  static final _id_hasParent = _class.instanceMethodId(
    r'hasParent',
    r'()Z',
  );

  static final _hasParent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasParent()`
  ///
  /// Checks if this node has a parent. Nodes won't have parents if (e.g.) they are newly created and not added as a child
  ///     to an existing node, or if they are a \#shallowClone(). In such cases, \#parent() will return {@code null}.
  ///@return if this node has a parent.
  bool hasParent() {
    return _hasParent(
      reference.pointer,
      _id_hasParent as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_attr = _class.instanceMethodId(
    r'attr',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _attr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String attr(java.lang.String attributeKey)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get an attribute's value by its key. __Case insensitive__
  ///
  /// To get an absolute URL from an attribute that may be a relative URL, prefix the key with <code>__abs:__</code>,
  /// which is a shortcut to the \#absUrl method.
  ///
  ///
  /// E.g.:
  /// <blockquote><code>String url = a.attr("abs:href");</code></blockquote>
  ///@param attributeKey The attribute key.
  ///@return The attribute, or empty string if not present (to avoid nulls).
  ///@see \#attributes()
  ///@see \#hasAttr(String)
  ///@see \#absUrl(String)
  jni$_.JString? attr(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _attr(
      reference.pointer,
      _id_attr as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_attributes = _class.instanceMethodId(
    r'attributes',
    r'()Lorg/jsoup/nodes/Attributes;',
  );

  static final _attributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract org.jsoup.nodes.Attributes attributes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the Element's attributes.
  ///@return attributes (which implements Iterable, with the same order as presented in the original HTML).
  jni$_.JObject? attributes() {
    return _attributes(
      reference.pointer,
      _id_attributes as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_attributesSize = _class.instanceMethodId(
    r'attributesSize',
    r'()I',
  );

  static final _attributesSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int attributesSize()`
  ///
  /// Get the number of attributes that this Node has.
  ///@return the number of attributes
  ///@since 1.14.2
  int attributesSize() {
    return _attributesSize(
      reference.pointer,
      _id_attributesSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_attr$1 = _class.instanceMethodId(
    r'attr',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Node;',
  );

  static final _attr$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node attr(java.lang.String attributeKey, java.lang.String attributeValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set an attribute (key=value). If the attribute already exists, it is replaced. The attribute key comparison is
  /// __case insensitive__. The key will be set with case sensitivity as set in the parser settings.
  ///@param attributeKey The attribute key.
  ///@param attributeValue The attribute value.
  ///@return this (for chaining)
  Node? attr$1(
    jni$_.JString? attributeKey,
    jni$_.JString? attributeValue,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    final _$attributeValue = attributeValue?.reference ?? jni$_.jNullReference;
    return _attr$1(
      reference.pointer,
      _id_attr$1 as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
      _$attributeValue.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_hasAttr = _class.instanceMethodId(
    r'hasAttr',
    r'(Ljava/lang/String;)Z',
  );

  static final _hasAttr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasAttr(java.lang.String attributeKey)`
  ///
  /// Test if this Node has an attribute. __Case insensitive__.
  ///@param attributeKey The attribute key to check.
  ///@return true if the attribute exists, false if not.
  bool hasAttr(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _hasAttr(
      reference.pointer,
      _id_hasAttr as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).boolean;
  }

  static final _id_removeAttr = _class.instanceMethodId(
    r'removeAttr',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Node;',
  );

  static final _removeAttr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node removeAttr(java.lang.String attributeKey)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove an attribute from this node.
  ///@param attributeKey The attribute to remove.
  ///@return this (for chaining)
  Node? removeAttr(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _removeAttr(
      reference.pointer,
      _id_removeAttr as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_clearAttributes = _class.instanceMethodId(
    r'clearAttributes',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _clearAttributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node clearAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Clear (remove) each of the attributes in this node.
  ///@return this, for chaining
  Node? clearAttributes() {
    return _clearAttributes(
      reference.pointer,
      _id_clearAttributes as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_baseUri = _class.instanceMethodId(
    r'baseUri',
    r'()Ljava/lang/String;',
  );

  static final _baseUri =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract java.lang.String baseUri()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the base URI that applies to this node. Will return an empty string if not defined. Used to make relative links
  ///     absolute.
  ///@return base URI
  ///@see \#absUrl
  jni$_.JString? baseUri() {
    return _baseUri(
      reference.pointer,
      _id_baseUri as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_setBaseUri = _class.instanceMethodId(
    r'setBaseUri',
    r'(Ljava/lang/String;)V',
  );

  static final _setBaseUri =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void setBaseUri(java.lang.String baseUri)`
  ///
  /// Update the base URI of this node and all of its descendants.
  ///@param baseUri base URI to set
  void setBaseUri(
    jni$_.JString? baseUri,
  ) {
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    _setBaseUri(
      reference.pointer,
      _id_setBaseUri as jni$_.JMethodIDPtr,
      _$baseUri.pointer,
    ).check();
  }

  static final _id_absUrl = _class.instanceMethodId(
    r'absUrl',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _absUrl =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.lang.String absUrl(java.lang.String attributeKey)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get an absolute URL from a URL attribute that may be relative (such as an <code>&lt;a href&gt;</code> or
  /// <code>&lt;img src&gt;</code>).
  ///
  /// E.g.: <code>String absUrl = linkEl.absUrl("href");</code>
  ///
  ///
  ///
  /// If the attribute value is already absolute (i.e. it starts with a protocol, like
  /// <code>http://</code> or <code>https://</code> etc), and it successfully parses as a URL, the attribute is
  /// returned directly. Otherwise, it is treated as a URL relative to the element's \#baseUri, and made
  /// absolute using that.
  ///
  ///
  ///
  /// As an alternate, you can use the \#attr method with the <code>abs:</code> prefix, e.g.:
  /// <code>String absUrl = linkEl.attr("abs:href");</code>
  ///
  ///
  ///@param attributeKey The attribute key
  ///@return An absolute URL if one could be made, or an empty string (not null) if the attribute was missing or
  /// could not be made successfully into a URL.
  ///@see \#attr
  ///@see java.net.URL\#URL(java.net.URL, String)
  jni$_.JString? absUrl(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _absUrl(
      reference.pointer,
      _id_absUrl as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_childNode = _class.instanceMethodId(
    r'childNode',
    r'(I)Lorg/jsoup/nodes/Node;',
  );

  static final _childNode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.nodes.Node childNode(int index)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get a child node by its 0-based index.
  ///@param index index of child node
  ///@return the child node at this index.
  ///@throws IndexOutOfBoundsException if the index is out of bounds.
  Node? childNode(
    int index,
  ) {
    return _childNode(
      reference.pointer,
      _id_childNode as jni$_.JMethodIDPtr,
      index,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_childNodes = _class.instanceMethodId(
    r'childNodes',
    r'()Ljava/util/List;',
  );

  static final _childNodes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.Node> childNodes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this node's children. Presented as an unmodifiable list: new children can not be added, but the child nodes
  ///     themselves can be manipulated.
  ///@return list of children. If no children, returns an empty list.
  jni$_.JList<Node?>? childNodes() {
    return _childNodes(
      reference.pointer,
      _id_childNodes as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<Node?>?>(
      const jni$_.$JList$NullableType$<Node?>($Node$NullableType$()),
    );
  }

  static final _id_childNodesCopy = _class.instanceMethodId(
    r'childNodesCopy',
    r'()Ljava/util/List;',
  );

  static final _childNodesCopy =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.Node> childNodesCopy()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a deep copy of this node's children. Changes made to these nodes will not be reflected in the original
  /// nodes
  ///@return a deep copy of this node's children
  jni$_.JList<Node?>? childNodesCopy() {
    return _childNodesCopy(
      reference.pointer,
      _id_childNodesCopy as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<Node?>?>(
      const jni$_.$JList$NullableType$<Node?>($Node$NullableType$()),
    );
  }

  static final _id_childNodeSize = _class.instanceMethodId(
    r'childNodeSize',
    r'()I',
  );

  static final _childNodeSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract int childNodeSize()`
  ///
  /// Get the number of child nodes that this node holds.
  ///@return the number of child nodes that this node holds.
  int childNodeSize() {
    return _childNodeSize(
      reference.pointer,
      _id_childNodeSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_empty = _class.instanceMethodId(
    r'empty',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _empty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public abstract org.jsoup.nodes.Node empty()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Delete all this node's children.
  ///@return this node, for chaining
  Node? empty() {
    return _empty(
      reference.pointer,
      _id_empty as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_parent = _class.instanceMethodId(
    r'parent',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _parent =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node parent()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets this node's parent node.
  ///@return parent node; or null if no parent.
  ///@see \#hasParent()
  Node? parent() {
    return _parent(
      reference.pointer,
      _id_parent as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_parentNode = _class.instanceMethodId(
    r'parentNode',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _parentNode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final org.jsoup.nodes.Node parentNode()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets this node's parent node. Not overridable by extending classes, so useful if you really just need the Node type.
  ///@return parent node; or null if no parent.
  Node? parentNode() {
    return _parentNode(
      reference.pointer,
      _id_parentNode as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_root = _class.instanceMethodId(
    r'root',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _root =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node root()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this node's root node; that is, its topmost ancestor. If this node is the top ancestor, returns {@code this}.
  ///@return topmost ancestor.
  Node? root() {
    return _root(
      reference.pointer,
      _id_root as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_ownerDocument = _class.instanceMethodId(
    r'ownerDocument',
    r'()Lorg/jsoup/nodes/Document;',
  );

  static final _ownerDocument =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Document ownerDocument()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the Document associated with this Node.
  ///@return the Document associated with this Node, or null if there is no such Document.
  document$_.Document? ownerDocument() {
    return _ownerDocument(
      reference.pointer,
      _id_ownerDocument as jni$_.JMethodIDPtr,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'()V',
  );

  static final _remove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void remove()`
  ///
  /// Remove (delete) this node from the DOM tree. If this node has children, they are also removed. If this node is
  /// an orphan, nothing happens.
  void remove() {
    _remove(reference.pointer, _id_remove as jni$_.JMethodIDPtr).check();
  }

  static final _id_before = _class.instanceMethodId(
    r'before',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Node;',
  );

  static final _before =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node before(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified HTML into the DOM before this node (as a preceding sibling).
  ///@param html HTML to add before this node
  ///@return this node, for chaining
  ///@see \#after(String)
  Node? before(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _before(
      reference.pointer,
      _id_before as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_before$1 = _class.instanceMethodId(
    r'before',
    r'(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Node;',
  );

  static final _before$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node before(org.jsoup.nodes.Node node)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified node into the DOM before this node (as a preceding sibling).
  ///@param node to add before this node
  ///@return this node, for chaining
  ///@see \#after(Node)
  Node? before$1(
    Node? node,
  ) {
    final _$node = node?.reference ?? jni$_.jNullReference;
    return _before$1(
      reference.pointer,
      _id_before$1 as jni$_.JMethodIDPtr,
      _$node.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_after = _class.instanceMethodId(
    r'after',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Node;',
  );

  static final _after =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node after(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified HTML into the DOM after this node (as a following sibling).
  ///@param html HTML to add after this node
  ///@return this node, for chaining
  ///@see \#before(String)
  Node? after(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _after(
      reference.pointer,
      _id_after as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_after$1 = _class.instanceMethodId(
    r'after',
    r'(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Node;',
  );

  static final _after$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node after(org.jsoup.nodes.Node node)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified node into the DOM after this node (as a following sibling).
  ///@param node to add after this node
  ///@return this node, for chaining
  ///@see \#before(Node)
  Node? after$1(
    Node? node,
  ) {
    final _$node = node?.reference ?? jni$_.jNullReference;
    return _after$1(
      reference.pointer,
      _id_after$1 as jni$_.JMethodIDPtr,
      _$node.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_wrap = _class.instanceMethodId(
    r'wrap',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Node;',
  );

  static final _wrap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node wrap(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Wrap the supplied HTML around this node.
  ///@param html HTML to wrap around this node, e.g. {@code <div class="head"></div>}. Can be arbitrarily deep. If
  ///     the input HTML does not parse to a result starting with an Element, this will be a no-op.
  ///@return this node, for chaining.
  Node? wrap(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _wrap(
      reference.pointer,
      _id_wrap as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_unwrap = _class.instanceMethodId(
    r'unwrap',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _unwrap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node unwrap()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Removes this node from the DOM, and moves its children up into the node's parent. This has the effect of dropping
  /// the node but keeping its children.
  ///
  /// For example, with the input html:
  ///
  ///
  /// {@code <div>One <span>Two __Three__</span></div>}
  ///
  /// Calling {@code element.unwrap()} on the {@code span} element will result in the html:
  /// {@code <div>One Two __Three__</div>}
  ///
  /// and the {@code "Two "} TextNode being returned.
  ///@return the first child of this node, after the node has been unwrapped. @{code Null} if the node had no children.
  ///@see \#remove()
  ///@see \#wrap(String)
  Node? unwrap() {
    return _unwrap(
      reference.pointer,
      _id_unwrap as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_replaceWith = _class.instanceMethodId(
    r'replaceWith',
    r'(Lorg/jsoup/nodes/Node;)V',
  );

  static final _replaceWith =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void replaceWith(org.jsoup.nodes.Node in)`
  ///
  /// Replace this node in the DOM with the supplied node.
  ///@param in the node that will replace the existing node.
  void replaceWith(
    Node? in$,
  ) {
    final _$in$ = in$?.reference ?? jni$_.jNullReference;
    _replaceWith(
      reference.pointer,
      _id_replaceWith as jni$_.JMethodIDPtr,
      _$in$.pointer,
    ).check();
  }

  static final _id_siblingNodes = _class.instanceMethodId(
    r'siblingNodes',
    r'()Ljava/util/List;',
  );

  static final _siblingNodes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.Node> siblingNodes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Retrieves this node's sibling nodes. Similar to \#childNodes() node.parent.childNodes(), but does not
  ///     include this node (a node is not a sibling of itself).
  ///@return node siblings. If the node has no parent, returns an empty list.
  jni$_.JList<Node?>? siblingNodes() {
    return _siblingNodes(
      reference.pointer,
      _id_siblingNodes as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<Node?>?>(
      const jni$_.$JList$NullableType$<Node?>($Node$NullableType$()),
    );
  }

  static final _id_nextSibling = _class.instanceMethodId(
    r'nextSibling',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _nextSibling =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node nextSibling()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this node's next sibling.
  ///@return next sibling, or {@code null} if this is the last sibling
  Node? nextSibling() {
    return _nextSibling(
      reference.pointer,
      _id_nextSibling as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_previousSibling = _class.instanceMethodId(
    r'previousSibling',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _previousSibling =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node previousSibling()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this node's previous sibling.
  ///@return the previous sibling, or @{code null} if this is the first sibling
  Node? previousSibling() {
    return _previousSibling(
      reference.pointer,
      _id_previousSibling as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_siblingIndex = _class.instanceMethodId(
    r'siblingIndex',
    r'()I',
  );

  static final _siblingIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int siblingIndex()`
  ///
  /// Get the list index of this node in its node sibling list. E.g. if this is the first node
  /// sibling, returns 0.
  ///@return position in node sibling list
  ///@see org.jsoup.nodes.Element\#elementSiblingIndex()
  int siblingIndex() {
    return _siblingIndex(
      reference.pointer,
      _id_siblingIndex as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_firstChild = _class.instanceMethodId(
    r'firstChild',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _firstChild =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node firstChild()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the first child node of this node, or {@code null} if there is none. This could be any Node type, such as an
  ///     Element, TextNode, Comment, etc. Use Element\#firstElementChild() to get the first Element child.
  ///@return the first child node, or null if there are no children.
  ///@see Element\#firstElementChild()
  ///@see \#lastChild()
  ///@since 1.15.2
  Node? firstChild() {
    return _firstChild(
      reference.pointer,
      _id_firstChild as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_lastChild = _class.instanceMethodId(
    r'lastChild',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _lastChild =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node lastChild()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the last child node of this node, or {@code null} if there is none.
  ///@return the last child node, or null if there are no children.
  ///@see Element\#lastElementChild()
  ///@see \#firstChild()
  ///@since 1.15.2
  Node? lastChild() {
    return _lastChild(
      reference.pointer,
      _id_lastChild as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_traverse = _class.instanceMethodId(
    r'traverse',
    r'(Lorg/jsoup/select/NodeVisitor;)Lorg/jsoup/nodes/Node;',
  );

  static final _traverse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node traverse(org.jsoup.select.NodeVisitor nodeVisitor)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Perform a depth-first traversal through this node and its descendants.
  ///@param nodeVisitor the visitor callbacks to perform on each node
  ///@return this node, for chaining
  Node? traverse(
    jni$_.JObject? nodeVisitor,
  ) {
    final _$nodeVisitor = nodeVisitor?.reference ?? jni$_.jNullReference;
    return _traverse(
      reference.pointer,
      _id_traverse as jni$_.JMethodIDPtr,
      _$nodeVisitor.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_forEachNode = _class.instanceMethodId(
    r'forEachNode',
    r'(Ljava/util/function/Consumer;)Lorg/jsoup/nodes/Node;',
  );

  static final _forEachNode =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node forEachNode(java.util.function.Consumer<? super org.jsoup.nodes.Node> action)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Perform the supplied action on this Node and each of its descendants, during a depth-first traversal. Nodes may be
  ///     inspected, changed, added, replaced, or removed.
  ///@param action the function to perform on the node
  ///@return this Node, for chaining
  ///@see Element\#forEach(Consumer)
  Node? forEachNode(
    jni$_.JObject? action,
  ) {
    final _$action = action?.reference ?? jni$_.jNullReference;
    return _forEachNode(
      reference.pointer,
      _id_forEachNode as jni$_.JMethodIDPtr,
      _$action.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_filter = _class.instanceMethodId(
    r'filter',
    r'(Lorg/jsoup/select/NodeFilter;)Lorg/jsoup/nodes/Node;',
  );

  static final _filter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Node filter(org.jsoup.select.NodeFilter nodeFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Perform a depth-first filtered traversal through this node and its descendants.
  ///@param nodeFilter the filter callbacks to perform on each node
  ///@return this node, for chaining
  Node? filter(
    jni$_.JObject? nodeFilter,
  ) {
    final _$nodeFilter = nodeFilter?.reference ?? jni$_.jNullReference;
    return _filter(
      reference.pointer,
      _id_filter as jni$_.JMethodIDPtr,
      _$nodeFilter.pointer,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_nodeStream = _class.instanceMethodId(
    r'nodeStream',
    r'()Ljava/util/stream/Stream;',
  );

  static final _nodeStream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<org.jsoup.nodes.Node> nodeStream()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a Stream of this Node and all of its descendant Nodes. The stream has document order.
  ///@return a stream of all nodes.
  ///@see Element\#stream()
  ///@since 1.17.1
  jni$_.JObject? nodeStream() {
    return _nodeStream(
      reference.pointer,
      _id_nodeStream as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_nodeStream$1 = _class.instanceMethodId(
    r'nodeStream',
    r'(Ljava/lang/Class;)Ljava/util/stream/Stream;',
  );

  static final _nodeStream$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.stream.Stream<T> nodeStream(java.lang.Class<T> type)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a Stream of this and descendant nodes, containing only nodes of the specified type. The stream has document
  ///     order.
  ///@return a stream of nodes filtered by type.
  ///@see Element\#stream()
  ///@since 1.17.1
  jni$_.JObject? nodeStream$1<$T extends jni$_.JObject?>(
    jni$_.JObject? type, {
    required jni$_.JType<$T> T,
  }) {
    final _$type = type?.reference ?? jni$_.jNullReference;
    return _nodeStream$1(
      reference.pointer,
      _id_nodeStream$1 as jni$_.JMethodIDPtr,
      _$type.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_outerHtml = _class.instanceMethodId(
    r'outerHtml',
    r'()Ljava/lang/String;',
  );

  static final _outerHtml =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String outerHtml()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the outer HTML of this node. For example, on a {@code p} element, may return {@code Para
  ///}.
  ///@return outer HTML
  ///@see Element\#html()
  ///@see Element\#text()
  jni$_.JString? outerHtml() {
    return _outerHtml(
      reference.pointer,
      _id_outerHtml as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_html = _class.instanceMethodId(
    r'html',
    r'(Ljava/lang/Appendable;)Ljava/lang/Appendable;',
  );

  static final _html =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T html(T appendable)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Write this node and its children to the given Appendable.
  ///@param appendable the Appendable to write to.
  ///@return the supplied Appendable, for chaining.
  $T? html<$T extends jni$_.JObject?>(
    $T? appendable, {
    required jni$_.JType<$T> T,
  }) {
    final _$appendable = appendable?.reference ?? jni$_.jNullReference;
    return _html(
      reference.pointer,
      _id_html as jni$_.JMethodIDPtr,
      _$appendable.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_sourceRange = _class.instanceMethodId(
    r'sourceRange',
    r'()Lorg/jsoup/nodes/Range;',
  );

  static final _sourceRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Range sourceRange()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the source range (start and end positions) in the original input source from which this node was parsed.
  ///     Position tracking must be enabled prior to parsing the content. For an Element, this will be the positions of the
  ///     start tag.
  ///@return the range for the start of the node, or {@code untracked} if its range was not tracked.
  ///@see org.jsoup.parser.Parser\#setTrackPosition(boolean)
  ///@see Range\#isImplicit()
  ///@see Element\#endSourceRange()
  ///@see Attributes\#sourceRange(String name)
  ///@since 1.15.2
  jni$_.JObject? sourceRange() {
    return _sourceRange(
      reference.pointer,
      _id_sourceRange as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets this node's outer HTML.
  ///@return outer HTML.
  ///@see \#outerHtml()
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_equals = _class.instanceMethodId(
    r'equals',
    r'(Ljava/lang/Object;)Z',
  );

  static final _equals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean equals(java.lang.Object o)`
  ///
  /// Check if this node is the same instance of another (object identity test).
  /// For an node value equality check, see \#hasSameValue(Object)
  ///
  ///@param o other object to compare to
  ///@return true if the content of this node is the same as the other
  ///@see Node\#hasSameValue(Object)
  bool equals(
    jni$_.JObject? o,
  ) {
    final _$o = o?.reference ?? jni$_.jNullReference;
    return _equals(
      reference.pointer,
      _id_equals as jni$_.JMethodIDPtr,
      _$o.pointer,
    ).boolean;
  }

  static final _id_hashCode$1 = _class.instanceMethodId(
    r'hashCode',
    r'()I',
  );

  static final _hashCode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int hashCode()`
  ///
  /// Provides a hashCode for this Node, based on its object identity. Changes to the Node's content will not impact the
  ///     result.
  ///@return an object identity based hashcode for this Node
  int hashCode$1() {
    return _hashCode$1(
      reference.pointer,
      _id_hashCode$1 as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_hasSameValue = _class.instanceMethodId(
    r'hasSameValue',
    r'(Ljava/lang/Object;)Z',
  );

  static final _hasSameValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasSameValue(java.lang.Object o)`
  ///
  /// Check if this node has the same content as another node. A node is considered the same if its name, attributes and content match the
  /// other node; particularly its position in the tree does not influence its similarity.
  ///@param o other object to compare to
  ///@return true if the content of this node is the same as the other
  bool hasSameValue(
    jni$_.JObject? o,
  ) {
    final _$o = o?.reference ?? jni$_.jNullReference;
    return _hasSameValue(
      reference.pointer,
      _id_hasSameValue as jni$_.JMethodIDPtr,
      _$o.pointer,
    ).boolean;
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node clone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a stand-alone, deep copy of this node, and all of its children. The cloned node will have no siblings or
  /// parent node. As a stand-alone object, any changes made to the clone or any of its children will not impact the
  /// original node.
  ///
  /// The cloned node may be adopted into another Document or node structure using Element\#appendChild(Node).
  ///@return a stand-alone cloned node, including clones of any children
  ///@see \#shallowClone()
  Node? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }

  static final _id_shallowClone = _class.instanceMethodId(
    r'shallowClone',
    r'()Lorg/jsoup/nodes/Node;',
  );

  static final _shallowClone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Node shallowClone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a stand-alone, shallow copy of this node. None of its children (if any) will be cloned, and it will have
  /// no parent or sibling nodes.
  ///@return a single independent copy of this node
  ///@see \#clone()
  Node? shallowClone() {
    return _shallowClone(
      reference.pointer,
      _id_shallowClone as jni$_.JMethodIDPtr,
    ).object<Node?>(const $Node$NullableType$());
  }
}

final class $Node$NullableType$ extends jni$_.JType<Node?> {
  @jni$_.internal
  const $Node$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Node;';

  @jni$_.internal
  @core$_.override
  Node? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Node.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Node?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Node$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Node$NullableType$) &&
        other is $Node$NullableType$;
  }
}

final class $Node$Type$ extends jni$_.JType<Node> {
  @jni$_.internal
  const $Node$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Node;';

  @jni$_.internal
  @core$_.override
  Node fromReference(jni$_.JReference reference) => Node.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Node?> get nullableType => const $Node$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Node$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Node$Type$) && other is $Node$Type$;
  }
}
