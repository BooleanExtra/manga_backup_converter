// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../select/Elements.dart' as elements$_;

import 'Node.dart' as node$_;

import 'TextNode.dart' as textnode$_;

/// from: `org.jsoup.nodes.Element`
///
/// An HTML Element consists of a tag name, attributes, and child nodes (including text nodes and other elements).
///
/// From an Element, you can extract data, traverse the node graph, and manipulate the HTML.
class Element extends node$_.Node {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Element> $type;

  @jni$_.internal
  Element.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/jsoup/nodes/Element');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Element?> nullableType = $Element$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Element> type = $Element$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String tag, java.lang.String namespace)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new, standalone element, in the specified namespace.
  ///@param tag tag name
  ///@param namespace namespace for this element
  factory Element(
    jni$_.JString? tag,
    jni$_.JString? namespace,
  ) {
    final _$tag = tag?.reference ?? jni$_.jNullReference;
    final _$namespace = namespace?.reference ?? jni$_.jNullReference;
    return Element.fromReference(
      _new$(
        _class.reference.pointer,
        _id_new$ as jni$_.JMethodIDPtr,
        _$tag.pointer,
        _$namespace.pointer,
      ).reference,
    );
  }

  static final _id_new$1 = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(java.lang.String tag)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new, standalone element, in the HTML namespace.
  ///@param tag tag name
  ///@see \#Element(String tag, String namespace)
  factory Element.new$1(
    jni$_.JString? tag,
  ) {
    final _$tag = tag?.reference ?? jni$_.jNullReference;
    return Element.fromReference(
      _new$1(
        _class.reference.pointer,
        _id_new$1 as jni$_.JMethodIDPtr,
        _$tag.pointer,
      ).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Lorg/jsoup/parser/Tag;Ljava/lang/String;Lorg/jsoup/nodes/Attributes;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.jsoup.parser.Tag tag, java.lang.String baseUri, org.jsoup.nodes.Attributes attributes)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new, standalone Element. (Standalone in that it has no parent.)
  ///@param tag tag of this element
  ///@param baseUri the base URI (optional, may be null to inherit from parent, or "" to clear parent's)
  ///@param attributes initial attributes (optional, may be null)
  ///@see \#appendChild(Node)
  ///@see \#appendElement(String)
  factory Element.new$2(
    jni$_.JObject? tag,
    jni$_.JString? baseUri,
    jni$_.JObject? attributes,
  ) {
    final _$tag = tag?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    final _$attributes = attributes?.reference ?? jni$_.jNullReference;
    return Element.fromReference(
      _new$2(
        _class.reference.pointer,
        _id_new$2 as jni$_.JMethodIDPtr,
        _$tag.pointer,
        _$baseUri.pointer,
        _$attributes.pointer,
      ).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Lorg/jsoup/parser/Tag;Ljava/lang/String;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public void <init>(org.jsoup.parser.Tag tag, java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new Element from a Tag and a base URI.
  ///@param tag element tag
  ///@param baseUri the base URI of this element. Optional, and will inherit from its parent, if any.
  ///@see Tag\#valueOf(String, ParseSettings)
  factory Element.new$3(
    jni$_.JObject? tag,
    jni$_.JString? baseUri,
  ) {
    final _$tag = tag?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return Element.fromReference(
      _new$3(
        _class.reference.pointer,
        _id_new$3 as jni$_.JMethodIDPtr,
        _$tag.pointer,
        _$baseUri.pointer,
      ).reference,
    );
  }

  static final _id_attributes = _class.instanceMethodId(
    r'attributes',
    r'()Lorg/jsoup/nodes/Attributes;',
  );

  static final _attributes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Attributes attributes()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JObject? attributes() {
    return _attributes(
      reference.pointer,
      _id_attributes as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_baseUri = _class.instanceMethodId(
    r'baseUri',
    r'()Ljava/lang/String;',
  );

  static final _baseUri =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String baseUri()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? baseUri() {
    return _baseUri(
      reference.pointer,
      _id_baseUri as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_childNodeSize = _class.instanceMethodId(
    r'childNodeSize',
    r'()I',
  );

  static final _childNodeSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int childNodeSize()`
  int childNodeSize() {
    return _childNodeSize(
      reference.pointer,
      _id_childNodeSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_nodeName = _class.instanceMethodId(
    r'nodeName',
    r'()Ljava/lang/String;',
  );

  static final _nodeName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String nodeName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? nodeName() {
    return _nodeName(
      reference.pointer,
      _id_nodeName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_tagName = _class.instanceMethodId(
    r'tagName',
    r'()Ljava/lang/String;',
  );

  static final _tagName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String tagName()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the name of the tag for this element. E.g. {@code div}. If you are using ParseSettings\#preserveCase case preserving parsing, this will return the source's original case.
  ///@return the tag name
  jni$_.JString? tagName() {
    return _tagName(
      reference.pointer,
      _id_tagName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_normalName = _class.instanceMethodId(
    r'normalName',
    r'()Ljava/lang/String;',
  );

  static final _normalName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String normalName()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the normalized name of this Element's tag. This will always be the lower-cased version of the tag, regardless
  /// of the tag case preserving setting of the parser. For e.g., {@code <DIV>} and {@code <div>} both have a
  /// normal name of {@code div}.
  ///@return normal name
  jni$_.JString? normalName() {
    return _normalName(
      reference.pointer,
      _id_normalName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_elementIs = _class.instanceMethodId(
    r'elementIs',
    r'(Ljava/lang/String;Ljava/lang/String;)Z',
  );

  static final _elementIs =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean elementIs(java.lang.String normalName, java.lang.String namespace)`
  ///
  /// Test if this Element has the specified normalized name, and is in the specified namespace.
  ///@param normalName a normalized element name (e.g. {@code div}).
  ///@param namespace the namespace
  ///@return true if the element's normal name matches exactly, and is in the specified namespace
  ///@since 1.17.2
  bool elementIs(
    jni$_.JString? normalName,
    jni$_.JString? namespace,
  ) {
    final _$normalName = normalName?.reference ?? jni$_.jNullReference;
    final _$namespace = namespace?.reference ?? jni$_.jNullReference;
    return _elementIs(
      reference.pointer,
      _id_elementIs as jni$_.JMethodIDPtr,
      _$normalName.pointer,
      _$namespace.pointer,
    ).boolean;
  }

  static final _id_tagName$1 = _class.instanceMethodId(
    r'tagName',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _tagName$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element tagName(java.lang.String tagName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Change (rename) the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with
  /// {@code el.tagName("div");}.
  ///@param tagName new tag name for this element
  ///@return this element, for chaining
  ///@see Elements\#tagName(String)
  Element? tagName$1(
    jni$_.JString? tagName,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    return _tagName$1(
      reference.pointer,
      _id_tagName$1 as jni$_.JMethodIDPtr,
      _$tagName.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_tagName$2 = _class.instanceMethodId(
    r'tagName',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _tagName$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element tagName(java.lang.String tagName, java.lang.String namespace)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Change (rename) the tag of this element. For example, convert a {@code <span>} to a {@code <div>} with
  /// {@code el.tagName("div");}.
  ///@param tagName new tag name for this element
  ///@param namespace the new namespace for this element
  ///@return this element, for chaining
  ///@see Elements\#tagName(String)
  Element? tagName$2(
    jni$_.JString? tagName,
    jni$_.JString? namespace,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    final _$namespace = namespace?.reference ?? jni$_.jNullReference;
    return _tagName$2(
      reference.pointer,
      _id_tagName$2 as jni$_.JMethodIDPtr,
      _$tagName.pointer,
      _$namespace.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_tag = _class.instanceMethodId(
    r'tag',
    r'()Lorg/jsoup/parser/Tag;',
  );

  static final _tag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.parser.Tag tag()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the Tag for this element.
  ///@return the tag object
  jni$_.JObject? tag() {
    return _tag(
      reference.pointer,
      _id_tag as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_isBlock = _class.instanceMethodId(
    r'isBlock',
    r'()Z',
  );

  static final _isBlock =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBlock()`
  ///
  /// Test if this element is a block-level element. (E.g. {@code <div> == true} or an inline element
  /// {@code <span> == false}).
  ///@return true if block, false if not (and thus inline)
  bool isBlock() {
    return _isBlock(
      reference.pointer,
      _id_isBlock as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_id = _class.instanceMethodId(
    r'id',
    r'()Ljava/lang/String;',
  );

  static final _id =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String id()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the {@code id} attribute of this element.
  ///@return The id attribute, if present, or an empty string if not.
  jni$_.JString? id() {
    return _id(
      reference.pointer,
      _id_id as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_id$1 = _class.instanceMethodId(
    r'id',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _id$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element id(java.lang.String id)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the {@code id} attribute of this element.
  ///@param id the ID value to use
  ///@return this Element, for chaining
  Element? id$1(
    jni$_.JString? id,
  ) {
    final _$id = id?.reference ?? jni$_.jNullReference;
    return _id$1(
      reference.pointer,
      _id_id$1 as jni$_.JMethodIDPtr,
      _$id.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_attr$2 = _class.instanceMethodId(
    r'attr',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _attr$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element attr(java.lang.String attributeKey, java.lang.String attributeValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set an attribute value on this element. If this element already has an attribute with the
  /// key, its value is updated; otherwise, a new attribute is added.
  ///@return this element
  Element? attr$2(
    jni$_.JString? attributeKey,
    jni$_.JString? attributeValue,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    final _$attributeValue = attributeValue?.reference ?? jni$_.jNullReference;
    return _attr$2(
      reference.pointer,
      _id_attr$2 as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
      _$attributeValue.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_attr$3 = _class.instanceMethodId(
    r'attr',
    r'(Ljava/lang/String;Z)Lorg/jsoup/nodes/Element;',
  );

  static final _attr$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `public org.jsoup.nodes.Element attr(java.lang.String attributeKey, boolean attributeValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set a boolean attribute value on this element. Setting to <code>true</code> sets the attribute value to "" and
  /// marks the attribute as boolean so no value is written out. Setting to <code>false</code> removes the attribute
  /// with the same key if it exists.
  ///@param attributeKey the attribute key
  ///@param attributeValue the attribute value
  ///@return this element
  Element? attr$3(
    jni$_.JString? attributeKey,
    bool attributeValue,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _attr$3(
      reference.pointer,
      _id_attr$3 as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
      attributeValue ? 1 : 0,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_attribute = _class.instanceMethodId(
    r'attribute',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Attribute;',
  );

  static final _attribute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Attribute attribute(java.lang.String key)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get an Attribute by key. Changes made via Attribute\#setKey(String), Attribute\#setValue(String) etc
  ///     will cascade back to this Element.
  ///@param key the (case-sensitive) attribute key
  ///@return the Attribute for this key, or null if not present.
  ///@since 1.17.2
  jni$_.JObject? attribute(
    jni$_.JString? key,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    return _attribute(
      reference.pointer,
      _id_attribute as jni$_.JMethodIDPtr,
      _$key.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_dataset = _class.instanceMethodId(
    r'dataset',
    r'()Ljava/util/Map;',
  );

  static final _dataset =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Map<java.lang.String, java.lang.String> dataset()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this element's HTML5 custom data attributes. Each attribute in the element that has a key
  /// starting with "data-" is included the dataset.
  ///
  /// E.g., the element {@code <div data-package="jsoup" data-language="Java" class="group">...} has the dataset
  /// {@code package=jsoup, language=java}.
  ///
  /// This map is a filtered view of the element's attribute map. Changes to one map (add, remove, update) are reflected
  /// in the other map.
  ///
  /// You can find elements that have data attributes using the {@code [^data-]} attribute key prefix selector.
  ///@return a map of {@code key=value} custom data attributes.
  jni$_.JMap<jni$_.JString?, jni$_.JString?>? dataset() {
    return _dataset(
      reference.pointer,
      _id_dataset as jni$_.JMethodIDPtr,
    ).object<jni$_.JMap<jni$_.JString?, jni$_.JString?>?>(
      const jni$_.$JMap$NullableType$<jni$_.JString?, jni$_.JString?>(
        jni$_.$JString$NullableType$(),
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_parent$1 = _class.instanceMethodId(
    r'parent',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _parent$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public final org.jsoup.nodes.Element parent()`
  /// The returned object must be released after use, by calling the [release] method.
  Element? parent$1() {
    return _parent$1(
      reference.pointer,
      _id_parent$1 as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_parents = _class.instanceMethodId(
    r'parents',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _parents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements parents()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this element's parent and ancestors, up to the document root.
  ///@return this element's stack of parents, starting with the closest first.
  elements$_.Elements? parents() {
    return _parents(
      reference.pointer,
      _id_parents as jni$_.JMethodIDPtr,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_child = _class.instanceMethodId(
    r'child',
    r'(I)Lorg/jsoup/nodes/Element;',
  );

  static final _child =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.nodes.Element child(int index)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get a child element of this element, by its 0-based index number.
  ///
  /// Note that an element can have both mixed Nodes and Elements as children. This method inspects
  /// a filtered list of children that are elements, and the index is based on that filtered list.
  ///
  ///
  ///@param index the index number of the element to retrieve
  ///@return the child element, if it exists, otherwise throws an {@code IndexOutOfBoundsException}
  ///@see \#childNode(int)
  Element? child(
    int index,
  ) {
    return _child(
      reference.pointer,
      _id_child as jni$_.JMethodIDPtr,
      index,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_childrenSize = _class.instanceMethodId(
    r'childrenSize',
    r'()I',
  );

  static final _childrenSize =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int childrenSize()`
  ///
  /// Get the number of child nodes of this element that are elements.
  ///
  /// This method works on the same filtered list like \#child(int). Use \#childNodes() and \#childNodeSize() to get the unfiltered Nodes (e.g. includes TextNodes etc.)
  ///
  ///
  ///@return the number of child nodes that are elements
  ///@see \#children()
  ///@see \#child(int)
  int childrenSize() {
    return _childrenSize(
      reference.pointer,
      _id_childrenSize as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_children = _class.instanceMethodId(
    r'children',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _children =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements children()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this element's child elements.
  ///
  /// This is effectively a filter on \#childNodes() to get Element nodes.
  ///
  ///
  ///@return child elements. If this element has no children, returns an empty list.
  ///@see \#childNodes()
  elements$_.Elements? children() {
    return _children(
      reference.pointer,
      _id_children as jni$_.JMethodIDPtr,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_stream = _class.instanceMethodId(
    r'stream',
    r'()Ljava/util/stream/Stream;',
  );

  static final _stream =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.stream.Stream<org.jsoup.nodes.Element> stream()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Returns a Stream of this Element and all of its descendant Elements. The stream has document order.
  ///@return a stream of this element and its descendants.
  ///@see \#nodeStream()
  ///@since 1.17.1
  jni$_.JObject? stream() {
    return _stream(
      reference.pointer,
      _id_stream as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_textNodes = _class.instanceMethodId(
    r'textNodes',
    r'()Ljava/util/List;',
  );

  static final _textNodes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.TextNode> textNodes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this element's child text nodes. The list is unmodifiable but the text nodes may be manipulated.
  ///
  /// This is effectively a filter on \#childNodes() to get Text nodes.
  ///@return child text nodes. If this element has no text nodes, returns an
  /// empty list.
  ///
  ///
  /// For example, with the input HTML: {@code One <span>Two</span> Three <br> Four
  ///} with the {@code p} element selected:
  /// <ul>
  ///     <li>{@code p.text()} = {@code "One Two Three Four"}</li>
  ///     <li>{@code p.ownText()} = {@code "One Three Four"}</li>
  ///     <li>{@code p.children()} = {@code Elements[<span>, <br>]}</li>
  ///     <li>{@code p.childNodes()} = {@code List<Node>["One ", <span>, " Three ", <br>, " Four"]}</li>
  ///     <li>{@code p.textNodes()} = {@code List<TextNode>["One ", " Three ", " Four"]}</li>
  /// </ul>
  jni$_.JList<textnode$_.TextNode?>? textNodes() {
    return _textNodes(
      reference.pointer,
      _id_textNodes as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<textnode$_.TextNode?>?>(
      const jni$_.$JList$NullableType$<textnode$_.TextNode?>(
        textnode$_.$TextNode$NullableType$(),
      ),
    );
  }

  static final _id_dataNodes = _class.instanceMethodId(
    r'dataNodes',
    r'()Ljava/util/List;',
  );

  static final _dataNodes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.DataNode> dataNodes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get this element's child data nodes. The list is unmodifiable but the data nodes may be manipulated.
  ///
  /// This is effectively a filter on \#childNodes() to get Data nodes.
  ///
  ///
  ///@return child data nodes. If this element has no data nodes, returns an
  /// empty list.
  ///@see \#data()
  jni$_.JList<jni$_.JObject?>? dataNodes() {
    return _dataNodes(
      reference.pointer,
      _id_dataNodes as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(
        jni$_.$JObject$NullableType$(),
      ),
    );
  }

  static final _id_select = _class.instanceMethodId(
    r'select',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _select =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements select(java.lang.String cssQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that match the Selector CSS query, with this element as the starting context. Matched elements
  /// may include this element, or any of its children.
  /// This method is generally more powerful to use than the DOM-type {@code getElementBy*} methods, because
  /// multiple filters can be combined, e.g.:
  ///
  /// <ul>
  /// <li>{@code el.select("a[href]")} - finds links ({@code a} tags with {@code href} attributes)
  /// <li>{@code el.select("a[href*=example.com]")} - finds links pointing to example.com (loosely)
  /// </ul>
  /// See the query syntax documentation in org.jsoup.select.Selector.
  ///
  /// Also known as {@code querySelectorAll()} in the Web DOM.
  ///
  ///@param cssQuery a Selector CSS-like query
  ///@return an Elements list containing elements that match the query (empty if none match)
  ///@see Selector selector query syntax
  ///@see QueryParser\#parse(String)
  ///@throws Selector.SelectorParseException (unchecked) on an invalid CSS query.
  elements$_.Elements? select(
    jni$_.JString? cssQuery,
  ) {
    final _$cssQuery = cssQuery?.reference ?? jni$_.jNullReference;
    return _select(
      reference.pointer,
      _id_select as jni$_.JMethodIDPtr,
      _$cssQuery.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_select$1 = _class.instanceMethodId(
    r'select',
    r'(Lorg/jsoup/select/Evaluator;)Lorg/jsoup/select/Elements;',
  );

  static final _select$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements select(org.jsoup.select.Evaluator evaluator)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that match the supplied Evaluator. This has the same functionality as \#select(String), but
  /// may be useful if you are running the same query many times (on many documents) and want to save the overhead of
  /// repeatedly parsing the CSS query.
  ///@param evaluator an element evaluator
  ///@return an Elements list containing elements that match the query (empty if none match)
  elements$_.Elements? select$1(
    jni$_.JObject? evaluator,
  ) {
    final _$evaluator = evaluator?.reference ?? jni$_.jNullReference;
    return _select$1(
      reference.pointer,
      _id_select$1 as jni$_.JMethodIDPtr,
      _$evaluator.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_selectFirst = _class.instanceMethodId(
    r'selectFirst',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _selectFirst =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element selectFirst(java.lang.String cssQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find the first Element that matches the Selector CSS query, with this element as the starting context.
  /// This is effectively the same as calling {@code element.select(query).first()}, but is more efficient as query
  /// execution stops on the first hit.
  ///
  /// Also known as {@code querySelector()} in the Web DOM.
  ///
  ///@param cssQuery cssQuery a Selector CSS-like query
  ///@return the first matching element, or __{@code null}__ if there is no match.
  ///@see \#expectFirst(String)
  Element? selectFirst(
    jni$_.JString? cssQuery,
  ) {
    final _$cssQuery = cssQuery?.reference ?? jni$_.jNullReference;
    return _selectFirst(
      reference.pointer,
      _id_selectFirst as jni$_.JMethodIDPtr,
      _$cssQuery.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_selectFirst$1 = _class.instanceMethodId(
    r'selectFirst',
    r'(Lorg/jsoup/select/Evaluator;)Lorg/jsoup/nodes/Element;',
  );

  static final _selectFirst$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element selectFirst(org.jsoup.select.Evaluator evaluator)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Finds the first Element that matches the supplied Evaluator, with this element as the starting context, or
  /// {@code null} if none match.
  ///@param evaluator an element evaluator
  ///@return the first matching element (walking down the tree, starting from this element), or {@code null} if none
  /// match.
  Element? selectFirst$1(
    jni$_.JObject? evaluator,
  ) {
    final _$evaluator = evaluator?.reference ?? jni$_.jNullReference;
    return _selectFirst$1(
      reference.pointer,
      _id_selectFirst$1 as jni$_.JMethodIDPtr,
      _$evaluator.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_expectFirst = _class.instanceMethodId(
    r'expectFirst',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _expectFirst =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element expectFirst(java.lang.String cssQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Just like \#selectFirst(String), but if there is no match, throws an IllegalArgumentException. This
  ///     is useful if you want to simply abort processing on a failed match.
  ///@param cssQuery a Selector CSS-like query
  ///@return the first matching element
  ///@throws IllegalArgumentException if no match is found
  ///@since 1.15.2
  Element? expectFirst(
    jni$_.JString? cssQuery,
  ) {
    final _$cssQuery = cssQuery?.reference ?? jni$_.jNullReference;
    return _expectFirst(
      reference.pointer,
      _id_expectFirst as jni$_.JMethodIDPtr,
      _$cssQuery.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_is$ = _class.instanceMethodId(
    r'is',
    r'(Ljava/lang/String;)Z',
  );

  static final _is$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean is(java.lang.String cssQuery)`
  ///
  /// Checks if this element matches the given Selector CSS query. Also knows as {@code matches()} in the Web
  /// DOM.
  ///@param cssQuery a Selector CSS query
  ///@return if this element matches the query
  bool is$(
    jni$_.JString? cssQuery,
  ) {
    final _$cssQuery = cssQuery?.reference ?? jni$_.jNullReference;
    return _is$(
      reference.pointer,
      _id_is$ as jni$_.JMethodIDPtr,
      _$cssQuery.pointer,
    ).boolean;
  }

  static final _id_is$1 = _class.instanceMethodId(
    r'is',
    r'(Lorg/jsoup/select/Evaluator;)Z',
  );

  static final _is$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean is(org.jsoup.select.Evaluator evaluator)`
  ///
  /// Check if this element matches the given evaluator.
  ///@param evaluator an element evaluator
  ///@return if this element matches
  bool is$1(
    jni$_.JObject? evaluator,
  ) {
    final _$evaluator = evaluator?.reference ?? jni$_.jNullReference;
    return _is$1(
      reference.pointer,
      _id_is$1 as jni$_.JMethodIDPtr,
      _$evaluator.pointer,
    ).boolean;
  }

  static final _id_closest = _class.instanceMethodId(
    r'closest',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _closest =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element closest(java.lang.String cssQuery)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find the closest element up the tree of parents that matches the specified CSS query. Will return itself, an
  /// ancestor, or {@code null} if there is no such matching element.
  ///@param cssQuery a Selector CSS query
  ///@return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not
  /// found.
  Element? closest(
    jni$_.JString? cssQuery,
  ) {
    final _$cssQuery = cssQuery?.reference ?? jni$_.jNullReference;
    return _closest(
      reference.pointer,
      _id_closest as jni$_.JMethodIDPtr,
      _$cssQuery.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_closest$1 = _class.instanceMethodId(
    r'closest',
    r'(Lorg/jsoup/select/Evaluator;)Lorg/jsoup/nodes/Element;',
  );

  static final _closest$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element closest(org.jsoup.select.Evaluator evaluator)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find the closest element up the tree of parents that matches the specified evaluator. Will return itself, an
  /// ancestor, or {@code null} if there is no such matching element.
  ///@param evaluator a query evaluator
  ///@return the closest ancestor element (possibly itself) that matches the provided evaluator. {@code null} if not
  /// found.
  Element? closest$1(
    jni$_.JObject? evaluator,
  ) {
    final _$evaluator = evaluator?.reference ?? jni$_.jNullReference;
    return _closest$1(
      reference.pointer,
      _id_closest$1 as jni$_.JMethodIDPtr,
      _$evaluator.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_selectXpath = _class.instanceMethodId(
    r'selectXpath',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _selectXpath =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements selectXpath(java.lang.String xpath)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find Elements that match the supplied {@index XPath} expression.
  ///     Note that for convenience of writing the Xpath expression, namespaces are disabled, and queries can be
  ///     expressed using the element's local name only.
  ///
  ///     By default, XPath 1.0 expressions are supported. If you would to use XPath 2.0 or higher, you can provide an
  ///     alternate XPathFactory implementation:
  ///
  ///     <ol>
  ///     <li>Add the implementation to your classpath. E.g. to use <a href="https://www.saxonica.com/products/products.xml">Saxon-HE</a>, add <a href="https://mvnrepository.com/artifact/net.sf.saxon/Saxon-HE">net.sf.saxon:Saxon-HE</a> to your build.</li>
  ///     <li>Set the system property <code>javax.xml.xpath.XPathFactory:jsoup</code> to the implementing classname. E.g.:<br>
  ///     <code>System.setProperty(W3CDom.XPathFactoryProperty, "net.sf.saxon.xpath.XPathFactoryImpl");</code>
  ///     </li>
  ///     </ol>
  ///@param xpath XPath expression
  ///@return matching elements, or an empty list if none match.
  ///@see \#selectXpath(String, Class)
  ///@since 1.14.3
  elements$_.Elements? selectXpath(
    jni$_.JString? xpath,
  ) {
    final _$xpath = xpath?.reference ?? jni$_.jNullReference;
    return _selectXpath(
      reference.pointer,
      _id_selectXpath as jni$_.JMethodIDPtr,
      _$xpath.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_selectXpath$1 = _class.instanceMethodId(
    r'selectXpath',
    r'(Ljava/lang/String;Ljava/lang/Class;)Ljava/util/List;',
  );

  static final _selectXpath$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public java.util.List<T> selectXpath(java.lang.String xpath, java.lang.Class<T> nodeType)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find Nodes that match the supplied XPath expression.
  ///     For example, to select TextNodes under {@code p} elements:
  ///
  ///     <pre>List&lt;TextNode&gt; textNodes = doc.selectXpath("//body//p//text()", TextNode.class);</pre>
  ///     Note that in the jsoup DOM, Attribute objects are not Nodes. To directly select attribute values, do something
  ///     like:
  ///
  ///     <pre>List&lt;String&gt; hrefs = doc.selectXpath("//a").eachAttr("href");</pre>
  ///@param xpath XPath expression
  ///@param nodeType the jsoup node type to return
  ///@see \#selectXpath(String)
  ///@return a list of matching nodes
  ///@since 1.14.3
  jni$_.JList<$T?>? selectXpath$1<$T extends jni$_.JObject?>(
    jni$_.JString? xpath,
    jni$_.JObject? nodeType, {
    required jni$_.JType<$T> T,
  }) {
    final _$xpath = xpath?.reference ?? jni$_.jNullReference;
    final _$nodeType = nodeType?.reference ?? jni$_.jNullReference;
    return _selectXpath$1(
      reference.pointer,
      _id_selectXpath$1 as jni$_.JMethodIDPtr,
      _$xpath.pointer,
      _$nodeType.pointer,
    ).object<jni$_.JList<$T?>?>(
      jni$_.$JList$NullableType$<$T?>(T.nullableType),
    );
  }

  static final _id_appendChild = _class.instanceMethodId(
    r'appendChild',
    r'(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;',
  );

  static final _appendChild =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element appendChild(org.jsoup.nodes.Node child)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert a node to the end of this Element's children. The incoming node will be re-parented.
  ///@param child node to add.
  ///@return this Element, for chaining
  ///@see \#prependChild(Node)
  ///@see \#insertChildren(int, Collection)
  Element? appendChild(
    node$_.Node? child,
  ) {
    final _$child = child?.reference ?? jni$_.jNullReference;
    return _appendChild(
      reference.pointer,
      _id_appendChild as jni$_.JMethodIDPtr,
      _$child.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_appendChildren = _class.instanceMethodId(
    r'appendChildren',
    r'(Ljava/util/Collection;)Lorg/jsoup/nodes/Element;',
  );

  static final _appendChildren =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element appendChildren(java.util.Collection<? extends org.jsoup.nodes.Node> children)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the given nodes to the end of this Element's children.
  ///@param children nodes to add
  ///@return this Element, for chaining
  ///@see \#insertChildren(int, Collection)
  Element? appendChildren(
    jni$_.JObject? children,
  ) {
    final _$children = children?.reference ?? jni$_.jNullReference;
    return _appendChildren(
      reference.pointer,
      _id_appendChildren as jni$_.JMethodIDPtr,
      _$children.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_appendTo = _class.instanceMethodId(
    r'appendTo',
    r'(Lorg/jsoup/nodes/Element;)Lorg/jsoup/nodes/Element;',
  );

  static final _appendTo =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element appendTo(org.jsoup.nodes.Element parent)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add this element to the supplied parent element, as its next child.
  ///@param parent element to which this element will be appended
  ///@return this element, so that you can continue modifying the element
  Element? appendTo(
    Element? parent,
  ) {
    final _$parent = parent?.reference ?? jni$_.jNullReference;
    return _appendTo(
      reference.pointer,
      _id_appendTo as jni$_.JMethodIDPtr,
      _$parent.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_prependChild = _class.instanceMethodId(
    r'prependChild',
    r'(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;',
  );

  static final _prependChild =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element prependChild(org.jsoup.nodes.Node child)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add a node to the start of this element's children.
  ///@param child node to add.
  ///@return this element, so that you can add more child nodes or elements.
  Element? prependChild(
    node$_.Node? child,
  ) {
    final _$child = child?.reference ?? jni$_.jNullReference;
    return _prependChild(
      reference.pointer,
      _id_prependChild as jni$_.JMethodIDPtr,
      _$child.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_prependChildren = _class.instanceMethodId(
    r'prependChildren',
    r'(Ljava/util/Collection;)Lorg/jsoup/nodes/Element;',
  );

  static final _prependChildren =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element prependChildren(java.util.Collection<? extends org.jsoup.nodes.Node> children)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the given nodes to the start of this Element's children.
  ///@param children nodes to add
  ///@return this Element, for chaining
  ///@see \#insertChildren(int, Collection)
  Element? prependChildren(
    jni$_.JObject? children,
  ) {
    final _$children = children?.reference ?? jni$_.jNullReference;
    return _prependChildren(
      reference.pointer,
      _id_prependChildren as jni$_.JMethodIDPtr,
      _$children.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_insertChildren = _class.instanceMethodId(
    r'insertChildren',
    r'(ILjava/util/Collection;)Lorg/jsoup/nodes/Element;',
  );

  static final _insertChildren =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element insertChildren(int index, java.util.Collection<? extends org.jsoup.nodes.Node> children)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the
  /// right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.
  ///@param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the
  /// end
  ///@param children child nodes to insert
  ///@return this element, for chaining.
  Element? insertChildren(
    int index,
    jni$_.JObject? children,
  ) {
    final _$children = children?.reference ?? jni$_.jNullReference;
    return _insertChildren(
      reference.pointer,
      _id_insertChildren as jni$_.JMethodIDPtr,
      index,
      _$children.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_insertChildren$1 = _class.instanceMethodId(
    r'insertChildren',
    r'(I[Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;',
  );

  static final _insertChildren$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element insertChildren(int index, org.jsoup.nodes.Node[] children)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Inserts the given child nodes into this element at the specified index. Current nodes will be shifted to the
  /// right. The inserted nodes will be moved from their current parent. To prevent moving, copy the nodes first.
  ///@param index 0-based index to insert children at. Specify {@code 0} to insert at the start, {@code -1} at the
  /// end
  ///@param children child nodes to insert
  ///@return this element, for chaining.
  Element? insertChildren$1(
    int index,
    jni$_.JArray<node$_.Node?>? children,
  ) {
    final _$children = children?.reference ?? jni$_.jNullReference;
    return _insertChildren$1(
      reference.pointer,
      _id_insertChildren$1 as jni$_.JMethodIDPtr,
      index,
      _$children.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_appendElement = _class.instanceMethodId(
    r'appendElement',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _appendElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element appendElement(java.lang.String tagName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new element by tag name, and add it as this Element's last child.
  ///@param tagName the name of the tag (e.g. {@code div}).
  ///@return the new element, to allow you to add content to it, e.g.:
  ///  {@code parent.appendElement("h1").attr("id", "header").text("Welcome");}
  Element? appendElement(
    jni$_.JString? tagName,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    return _appendElement(
      reference.pointer,
      _id_appendElement as jni$_.JMethodIDPtr,
      _$tagName.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_appendElement$1 = _class.instanceMethodId(
    r'appendElement',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _appendElement$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element appendElement(java.lang.String tagName, java.lang.String namespace)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new element by tag name and namespace, add it as this Element's last child.
  ///@param tagName the name of the tag (e.g. {@code div}).
  ///@param namespace the namespace of the tag (e.g. Parser\#NamespaceHtml)
  ///@return the new element, in the specified namespace
  Element? appendElement$1(
    jni$_.JString? tagName,
    jni$_.JString? namespace,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    final _$namespace = namespace?.reference ?? jni$_.jNullReference;
    return _appendElement$1(
      reference.pointer,
      _id_appendElement$1 as jni$_.JMethodIDPtr,
      _$tagName.pointer,
      _$namespace.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_prependElement = _class.instanceMethodId(
    r'prependElement',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _prependElement =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element prependElement(java.lang.String tagName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new element by tag name, and add it as this Element's first child.
  ///@param tagName the name of the tag (e.g. {@code div}).
  ///@return the new element, to allow you to add content to it, e.g.:
  ///  {@code parent.prependElement("h1").attr("id", "header").text("Welcome");}
  Element? prependElement(
    jni$_.JString? tagName,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    return _prependElement(
      reference.pointer,
      _id_prependElement as jni$_.JMethodIDPtr,
      _$tagName.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_prependElement$1 = _class.instanceMethodId(
    r'prependElement',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _prependElement$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element prependElement(java.lang.String tagName, java.lang.String namespace)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new element by tag name and namespace, and add it as this Element's first child.
  ///@param tagName the name of the tag (e.g. {@code div}).
  ///@param namespace the namespace of the tag (e.g. Parser\#NamespaceHtml)
  ///@return the new element, in the specified namespace
  Element? prependElement$1(
    jni$_.JString? tagName,
    jni$_.JString? namespace,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    final _$namespace = namespace?.reference ?? jni$_.jNullReference;
    return _prependElement$1(
      reference.pointer,
      _id_prependElement$1 as jni$_.JMethodIDPtr,
      _$tagName.pointer,
      _$namespace.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_appendText = _class.instanceMethodId(
    r'appendText',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _appendText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element appendText(java.lang.String text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create and append a new TextNode to this element.
  ///@param text the (un-encoded) text to add
  ///@return this element
  Element? appendText(
    jni$_.JString? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _appendText(
      reference.pointer,
      _id_appendText as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_prependText = _class.instanceMethodId(
    r'prependText',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _prependText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element prependText(java.lang.String text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create and prepend a new TextNode to this element.
  ///@param text the decoded text to add
  ///@return this element
  Element? prependText(
    jni$_.JString? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _prependText(
      reference.pointer,
      _id_prependText as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element append(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add inner HTML to this element. The supplied HTML will be parsed, and each node appended to the end of the children.
  ///@param html HTML to add inside this element, after the existing HTML
  ///@return this element
  ///@see \#html(String)
  Element? append(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_prepend = _class.instanceMethodId(
    r'prepend',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _prepend =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element prepend(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add inner HTML into this element. The supplied HTML will be parsed, and each node prepended to the start of the element's children.
  ///@param html HTML to add inside this element, before the existing HTML
  ///@return this element
  ///@see \#html(String)
  Element? prepend(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _prepend(
      reference.pointer,
      _id_prepend as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_before$2 = _class.instanceMethodId(
    r'before',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _before$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element before(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified HTML into the DOM before this element (as a preceding sibling).
  ///@param html HTML to add before this element
  ///@return this element, for chaining
  ///@see \#after(String)
  Element? before$2(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _before$2(
      reference.pointer,
      _id_before$2 as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_before$3 = _class.instanceMethodId(
    r'before',
    r'(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;',
  );

  static final _before$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element before(org.jsoup.nodes.Node node)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified node into the DOM before this node (as a preceding sibling).
  ///@param node to add before this element
  ///@return this Element, for chaining
  ///@see \#after(Node)
  Element? before$3(
    node$_.Node? node,
  ) {
    final _$node = node?.reference ?? jni$_.jNullReference;
    return _before$3(
      reference.pointer,
      _id_before$3 as jni$_.JMethodIDPtr,
      _$node.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_after$2 = _class.instanceMethodId(
    r'after',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _after$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element after(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified HTML into the DOM after this element (as a following sibling).
  ///@param html HTML to add after this element
  ///@return this element, for chaining
  ///@see \#before(String)
  Element? after$2(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _after$2(
      reference.pointer,
      _id_after$2 as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_after$3 = _class.instanceMethodId(
    r'after',
    r'(Lorg/jsoup/nodes/Node;)Lorg/jsoup/nodes/Element;',
  );

  static final _after$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element after(org.jsoup.nodes.Node node)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the specified node into the DOM after this node (as a following sibling).
  ///@param node to add after this element
  ///@return this element, for chaining
  ///@see \#before(Node)
  Element? after$3(
    node$_.Node? node,
  ) {
    final _$node = node?.reference ?? jni$_.jNullReference;
    return _after$3(
      reference.pointer,
      _id_after$3 as jni$_.JMethodIDPtr,
      _$node.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_empty$1 = _class.instanceMethodId(
    r'empty',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _empty$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element empty()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove all the element's child nodes. Any attributes are left as-is. Each child node has its parent set to
  /// {@code null}.
  ///@return this element
  Element? empty$1() {
    return _empty$1(
      reference.pointer,
      _id_empty$1 as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_wrap$1 = _class.instanceMethodId(
    r'wrap',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _wrap$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element wrap(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Wrap the supplied HTML around this element.
  ///@param html HTML to wrap around this element, e.g. {@code <div class="head"></div>}. Can be arbitrarily deep.
  ///@return this element, for chaining.
  Element? wrap$1(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _wrap$1(
      reference.pointer,
      _id_wrap$1 as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_cssSelector = _class.instanceMethodId(
    r'cssSelector',
    r'()Ljava/lang/String;',
  );

  static final _cssSelector =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String cssSelector()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get a CSS selector that will uniquely select this element.
  ///
  /// If the element has an ID, returns \#id;
  /// otherwise returns the parent (if any) CSS selector, followed by {@literal '>'},
  /// followed by a unique selector for the element (tag.class.class:nth-child(n)).
  ///
  ///
  ///@return the CSS Path that can be used to retrieve the element in a selector.
  jni$_.JString? cssSelector() {
    return _cssSelector(
      reference.pointer,
      _id_cssSelector as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_siblingElements = _class.instanceMethodId(
    r'siblingElements',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _siblingElements =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements siblingElements()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get sibling elements. If the element has no sibling elements, returns an empty list. An element is not a sibling
  /// of itself, so will not be included in the returned list.
  ///@return sibling elements
  elements$_.Elements? siblingElements() {
    return _siblingElements(
      reference.pointer,
      _id_siblingElements as jni$_.JMethodIDPtr,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_nextElementSibling = _class.instanceMethodId(
    r'nextElementSibling',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _nextElementSibling =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element nextElementSibling()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the next sibling element of this element. E.g., if a {@code div} contains two {@code p}s,
  /// the {@code nextElementSibling} of the first {@code p} is the second {@code p}.
  ///
  /// This is similar to \#nextSibling(), but specifically finds only Elements
  ///
  ///
  ///@return the next element, or null if there is no next element
  ///@see \#previousElementSibling()
  Element? nextElementSibling() {
    return _nextElementSibling(
      reference.pointer,
      _id_nextElementSibling as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_nextElementSiblings = _class.instanceMethodId(
    r'nextElementSiblings',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _nextElementSiblings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements nextElementSiblings()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the sibling elements that come after this element.
  ///@return each of the element siblings after this element, or an empty list if there are no next sibling elements
  elements$_.Elements? nextElementSiblings() {
    return _nextElementSiblings(
      reference.pointer,
      _id_nextElementSiblings as jni$_.JMethodIDPtr,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_previousElementSibling = _class.instanceMethodId(
    r'previousElementSibling',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _previousElementSibling =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element previousElementSibling()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the previous element sibling of this element.
  ///@return the previous element, or null if there is no previous element
  ///@see \#nextElementSibling()
  Element? previousElementSibling() {
    return _previousElementSibling(
      reference.pointer,
      _id_previousElementSibling as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_previousElementSiblings = _class.instanceMethodId(
    r'previousElementSiblings',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _previousElementSiblings =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements previousElementSiblings()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the element siblings before this element.
  ///@return the previous element siblings, or an empty list if there are none.
  elements$_.Elements? previousElementSiblings() {
    return _previousElementSiblings(
      reference.pointer,
      _id_previousElementSiblings as jni$_.JMethodIDPtr,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_firstElementSibling = _class.instanceMethodId(
    r'firstElementSibling',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _firstElementSibling =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element firstElementSibling()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the first Element sibling of this element. That may be this element.
  ///@return the first sibling that is an element (aka the parent's first element child)
  Element? firstElementSibling() {
    return _firstElementSibling(
      reference.pointer,
      _id_firstElementSibling as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_elementSiblingIndex = _class.instanceMethodId(
    r'elementSiblingIndex',
    r'()I',
  );

  static final _elementSiblingIndex =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallIntMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public int elementSiblingIndex()`
  ///
  /// Get the list index of this element in its element sibling list. I.e. if this is the first element
  /// sibling, returns 0.
  ///@return position in element sibling list
  int elementSiblingIndex() {
    return _elementSiblingIndex(
      reference.pointer,
      _id_elementSiblingIndex as jni$_.JMethodIDPtr,
    ).integer;
  }

  static final _id_lastElementSibling = _class.instanceMethodId(
    r'lastElementSibling',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _lastElementSibling =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element lastElementSibling()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the last element sibling of this element. That may be this element.
  ///@return the last sibling that is an element (aka the parent's last element child)
  Element? lastElementSibling() {
    return _lastElementSibling(
      reference.pointer,
      _id_lastElementSibling as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_firstElementChild = _class.instanceMethodId(
    r'firstElementChild',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _firstElementChild =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element firstElementChild()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the first child of this Element that is an Element, or {@code null} if there is none.
  ///@return the first Element child node, or null.
  ///@see \#firstChild()
  ///@see \#lastElementChild()
  ///@since 1.15.2
  Element? firstElementChild() {
    return _firstElementChild(
      reference.pointer,
      _id_firstElementChild as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_lastElementChild = _class.instanceMethodId(
    r'lastElementChild',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _lastElementChild =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element lastElementChild()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the last child of this Element that is an Element, or @{code null} if there is none.
  ///@return the last Element child node, or null.
  ///@see \#lastChild()
  ///@see \#firstElementChild()
  ///@since 1.15.2
  Element? lastElementChild() {
    return _lastElementChild(
      reference.pointer,
      _id_lastElementChild as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_getElementsByTag = _class.instanceMethodId(
    r'getElementsByTag',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByTag =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByTag(java.lang.String tagName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Finds elements, including and recursively under this element, with the specified tag name.
  ///@param tagName The tag name to search for (case insensitively).
  ///@return a matching unmodifiable list of elements. Will be empty if this element and none of its children match.
  elements$_.Elements? getElementsByTag(
    jni$_.JString? tagName,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    return _getElementsByTag(
      reference.pointer,
      _id_getElementsByTag as jni$_.JMethodIDPtr,
      _$tagName.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementById = _class.instanceMethodId(
    r'getElementById',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _getElementById =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element getElementById(java.lang.String id)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find an element by ID, including or under this element.
  ///
  /// Note that this finds the first matching ID, starting with this element. If you search down from a different
  /// starting point, it is possible to find a different element by ID. For unique element by ID within a Document,
  /// use Document\#getElementById(String)
  ///@param id The ID to search for.
  ///@return The first matching element by ID, starting with this element, or null if none found.
  Element? getElementById(
    jni$_.JString? id,
  ) {
    final _$id = id?.reference ?? jni$_.jNullReference;
    return _getElementById(
      reference.pointer,
      _id_getElementById as jni$_.JMethodIDPtr,
      _$id.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_getElementsByClass = _class.instanceMethodId(
    r'getElementsByClass',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByClass(java.lang.String className)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have this class, including or under this element. Case-insensitive.
  ///
  /// Elements can have multiple classes (e.g. {@code <div class="header round first">}). This method
  /// checks each class, so you can find the above with {@code el.getElementsByClass("header");}.
  ///@param className the name of the class to search for.
  ///@return elements with the supplied class name, empty if none
  ///@see \#hasClass(String)
  ///@see \#classNames()
  elements$_.Elements? getElementsByClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _getElementsByClass(
      reference.pointer,
      _id_getElementsByClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttribute = _class.instanceMethodId(
    r'getElementsByAttribute',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttribute =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttribute(java.lang.String key)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have a named attribute set. Case-insensitive.
  ///@param key name of the attribute, e.g. {@code href}
  ///@return elements that have this attribute, empty if none
  elements$_.Elements? getElementsByAttribute(
    jni$_.JString? key,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    return _getElementsByAttribute(
      reference.pointer,
      _id_getElementsByAttribute as jni$_.JMethodIDPtr,
      _$key.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeStarting = _class.instanceMethodId(
    r'getElementsByAttributeStarting',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeStarting =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeStarting(java.lang.String keyPrefix)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have an attribute name starting with the supplied prefix. Use {@code data-} to find elements
  /// that have HTML5 datasets.
  ///@param keyPrefix name prefix of the attribute e.g. {@code data-}
  ///@return elements that have attribute names that start with the prefix, empty if none.
  elements$_.Elements? getElementsByAttributeStarting(
    jni$_.JString? keyPrefix,
  ) {
    final _$keyPrefix = keyPrefix?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeStarting(
      reference.pointer,
      _id_getElementsByAttributeStarting as jni$_.JMethodIDPtr,
      _$keyPrefix.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeValue = _class.instanceMethodId(
    r'getElementsByAttributeValue',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeValue =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeValue(java.lang.String key, java.lang.String value)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have an attribute with the specific value. Case-insensitive.
  ///@param key name of the attribute
  ///@param value value of the attribute
  ///@return elements that have this attribute with this value, empty if none
  elements$_.Elements? getElementsByAttributeValue(
    jni$_.JString? key,
    jni$_.JString? value,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$value = value?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeValue(
      reference.pointer,
      _id_getElementsByAttributeValue as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$value.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeValueNot = _class.instanceMethodId(
    r'getElementsByAttributeValueNot',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeValueNot =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeValueNot(java.lang.String key, java.lang.String value)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that either do not have this attribute, or have it with a different value. Case-insensitive.
  ///@param key name of the attribute
  ///@param value value of the attribute
  ///@return elements that do not have a matching attribute
  elements$_.Elements? getElementsByAttributeValueNot(
    jni$_.JString? key,
    jni$_.JString? value,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$value = value?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeValueNot(
      reference.pointer,
      _id_getElementsByAttributeValueNot as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$value.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeValueStarting = _class.instanceMethodId(
    r'getElementsByAttributeValueStarting',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeValueStarting =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeValueStarting(java.lang.String key, java.lang.String valuePrefix)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have attributes that start with the value prefix. Case-insensitive.
  ///@param key name of the attribute
  ///@param valuePrefix start of attribute value
  ///@return elements that have attributes that start with the value prefix
  elements$_.Elements? getElementsByAttributeValueStarting(
    jni$_.JString? key,
    jni$_.JString? valuePrefix,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$valuePrefix = valuePrefix?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeValueStarting(
      reference.pointer,
      _id_getElementsByAttributeValueStarting as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$valuePrefix.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeValueEnding = _class.instanceMethodId(
    r'getElementsByAttributeValueEnding',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeValueEnding =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeValueEnding(java.lang.String key, java.lang.String valueSuffix)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have attributes that end with the value suffix. Case-insensitive.
  ///@param key name of the attribute
  ///@param valueSuffix end of the attribute value
  ///@return elements that have attributes that end with the value suffix
  elements$_.Elements? getElementsByAttributeValueEnding(
    jni$_.JString? key,
    jni$_.JString? valueSuffix,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$valueSuffix = valueSuffix?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeValueEnding(
      reference.pointer,
      _id_getElementsByAttributeValueEnding as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$valueSuffix.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeValueContaining = _class.instanceMethodId(
    r'getElementsByAttributeValueContaining',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeValueContaining =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeValueContaining(java.lang.String key, java.lang.String match)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have attributes whose value contains the match string. Case-insensitive.
  ///@param key name of the attribute
  ///@param match substring of value to search for
  ///@return elements that have attributes containing this text
  elements$_.Elements? getElementsByAttributeValueContaining(
    jni$_.JString? key,
    jni$_.JString? match,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$match = match?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeValueContaining(
      reference.pointer,
      _id_getElementsByAttributeValueContaining as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$match.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeValueMatching = _class.instanceMethodId(
    r'getElementsByAttributeValueMatching',
    r'(Ljava/lang/String;Ljava/util/regex/Pattern;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeValueMatching =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeValueMatching(java.lang.String key, java.util.regex.Pattern pattern)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have an attribute whose value matches the supplied regular expression.
  ///@param key name of the attribute
  ///@param pattern compiled regular expression to match against attribute values
  ///@return elements that have attributes matching this regular expression
  elements$_.Elements? getElementsByAttributeValueMatching(
    jni$_.JString? key,
    jni$_.JObject? pattern,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$pattern = pattern?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeValueMatching(
      reference.pointer,
      _id_getElementsByAttributeValueMatching as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$pattern.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByAttributeValueMatching$1 = _class.instanceMethodId(
    r'getElementsByAttributeValueMatching',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByAttributeValueMatching$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByAttributeValueMatching(java.lang.String key, java.lang.String regex)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that have attributes whose values match the supplied regular expression.
  ///@param key name of the attribute
  ///@param regex regular expression to match against attribute values. You can use <a href="http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html\#embedded">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.
  ///@return elements that have attributes matching this regular expression
  elements$_.Elements? getElementsByAttributeValueMatching$1(
    jni$_.JString? key,
    jni$_.JString? regex,
  ) {
    final _$key = key?.reference ?? jni$_.jNullReference;
    final _$regex = regex?.reference ?? jni$_.jNullReference;
    return _getElementsByAttributeValueMatching$1(
      reference.pointer,
      _id_getElementsByAttributeValueMatching$1 as jni$_.JMethodIDPtr,
      _$key.pointer,
      _$regex.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByIndexLessThan = _class.instanceMethodId(
    r'getElementsByIndexLessThan',
    r'(I)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByIndexLessThan =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByIndexLessThan(int index)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements whose sibling index is less than the supplied index.
  ///@param index 0-based index
  ///@return elements less than index
  elements$_.Elements? getElementsByIndexLessThan(
    int index,
  ) {
    return _getElementsByIndexLessThan(
      reference.pointer,
      _id_getElementsByIndexLessThan as jni$_.JMethodIDPtr,
      index,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByIndexGreaterThan = _class.instanceMethodId(
    r'getElementsByIndexGreaterThan',
    r'(I)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByIndexGreaterThan =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByIndexGreaterThan(int index)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements whose sibling index is greater than the supplied index.
  ///@param index 0-based index
  ///@return elements greater than index
  elements$_.Elements? getElementsByIndexGreaterThan(
    int index,
  ) {
    return _getElementsByIndexGreaterThan(
      reference.pointer,
      _id_getElementsByIndexGreaterThan as jni$_.JMethodIDPtr,
      index,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsByIndexEquals = _class.instanceMethodId(
    r'getElementsByIndexEquals',
    r'(I)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsByIndexEquals =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              int,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsByIndexEquals(int index)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements whose sibling index is equal to the supplied index.
  ///@param index 0-based index
  ///@return elements equal to index
  elements$_.Elements? getElementsByIndexEquals(
    int index,
  ) {
    return _getElementsByIndexEquals(
      reference.pointer,
      _id_getElementsByIndexEquals as jni$_.JMethodIDPtr,
      index,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsContainingText = _class.instanceMethodId(
    r'getElementsContainingText',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsContainingText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsContainingText(java.lang.String searchText)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that contain the specified string. The search is case-insensitive. The text may appear directly
  /// in the element, or in any of its descendants.
  ///@param searchText to look for in the element's text
  ///@return elements that contain the string, case-insensitive.
  ///@see Element\#text()
  elements$_.Elements? getElementsContainingText(
    jni$_.JString? searchText,
  ) {
    final _$searchText = searchText?.reference ?? jni$_.jNullReference;
    return _getElementsContainingText(
      reference.pointer,
      _id_getElementsContainingText as jni$_.JMethodIDPtr,
      _$searchText.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsContainingOwnText = _class.instanceMethodId(
    r'getElementsContainingOwnText',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsContainingOwnText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsContainingOwnText(java.lang.String searchText)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements that directly contain the specified string. The search is case-insensitive. The text must appear directly
  /// in the element, not in any of its descendants.
  ///@param searchText to look for in the element's own text
  ///@return elements that contain the string, case-insensitive.
  ///@see Element\#ownText()
  elements$_.Elements? getElementsContainingOwnText(
    jni$_.JString? searchText,
  ) {
    final _$searchText = searchText?.reference ?? jni$_.jNullReference;
    return _getElementsContainingOwnText(
      reference.pointer,
      _id_getElementsContainingOwnText as jni$_.JMethodIDPtr,
      _$searchText.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsMatchingText = _class.instanceMethodId(
    r'getElementsMatchingText',
    r'(Ljava/util/regex/Pattern;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsMatchingText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsMatchingText(java.util.regex.Pattern pattern)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements whose text matches the supplied regular expression.
  ///@param pattern regular expression to match text against
  ///@return elements matching the supplied regular expression.
  ///@see Element\#text()
  elements$_.Elements? getElementsMatchingText(
    jni$_.JObject? pattern,
  ) {
    final _$pattern = pattern?.reference ?? jni$_.jNullReference;
    return _getElementsMatchingText(
      reference.pointer,
      _id_getElementsMatchingText as jni$_.JMethodIDPtr,
      _$pattern.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsMatchingText$1 = _class.instanceMethodId(
    r'getElementsMatchingText',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsMatchingText$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsMatchingText(java.lang.String regex)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements whose text matches the supplied regular expression.
  ///@param regex regular expression to match text against. You can use <a href="http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html\#embedded">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.
  ///@return elements matching the supplied regular expression.
  ///@see Element\#text()
  elements$_.Elements? getElementsMatchingText$1(
    jni$_.JString? regex,
  ) {
    final _$regex = regex?.reference ?? jni$_.jNullReference;
    return _getElementsMatchingText$1(
      reference.pointer,
      _id_getElementsMatchingText$1 as jni$_.JMethodIDPtr,
      _$regex.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsMatchingOwnText = _class.instanceMethodId(
    r'getElementsMatchingOwnText',
    r'(Ljava/util/regex/Pattern;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsMatchingOwnText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsMatchingOwnText(java.util.regex.Pattern pattern)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements whose own text matches the supplied regular expression.
  ///@param pattern regular expression to match text against
  ///@return elements matching the supplied regular expression.
  ///@see Element\#ownText()
  elements$_.Elements? getElementsMatchingOwnText(
    jni$_.JObject? pattern,
  ) {
    final _$pattern = pattern?.reference ?? jni$_.jNullReference;
    return _getElementsMatchingOwnText(
      reference.pointer,
      _id_getElementsMatchingOwnText as jni$_.JMethodIDPtr,
      _$pattern.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getElementsMatchingOwnText$1 = _class.instanceMethodId(
    r'getElementsMatchingOwnText',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _getElementsMatchingOwnText$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements getElementsMatchingOwnText(java.lang.String regex)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find elements whose own text matches the supplied regular expression.
  ///@param regex regular expression to match text against. You can use <a href="http://java.sun.com/docs/books/tutorial/essential/regex/pattern.html\#embedded">embedded flags</a> (such as {@code (?i)} and {@code (?m)}) to control regex options.
  ///@return elements matching the supplied regular expression.
  ///@see Element\#ownText()
  elements$_.Elements? getElementsMatchingOwnText$1(
    jni$_.JString? regex,
  ) {
    final _$regex = regex?.reference ?? jni$_.jNullReference;
    return _getElementsMatchingOwnText$1(
      reference.pointer,
      _id_getElementsMatchingOwnText$1 as jni$_.JMethodIDPtr,
      _$regex.pointer,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_getAllElements = _class.instanceMethodId(
    r'getAllElements',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _getAllElements =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements getAllElements()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find all elements under this element (including self, and children of children).
  ///@return all elements
  elements$_.Elements? getAllElements() {
    return _getAllElements(
      reference.pointer,
      _id_getAllElements as jni$_.JMethodIDPtr,
    ).object<elements$_.Elements?>(const elements$_.$Elements$NullableType$());
  }

  static final _id_text = _class.instanceMethodId(
    r'text',
    r'()Ljava/lang/String;',
  );

  static final _text =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String text()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the __normalized, combined text__ of this element and all its children. Whitespace is normalized and
  ///     trimmed.
  ///     For example, given HTML {@code Hello  __there__ now!
  ///}, {@code p.text()} returns {@code "Hello there
  ///    now!"}
  ///     If you do not want normalized text, use \#wholeText(). If you want just the text of this node (and not
  ///     children), use \#ownText()
  ///     Note that this method returns the textual content that would be presented to a reader. The contents of data
  ///     nodes (such as {@code <script>} tags) are not considered text. Use \#data() or \#html() to retrieve
  ///     that content.
  ///@return decoded, normalized text, or empty string if none.
  ///@see \#wholeText()
  ///@see \#ownText()
  ///@see \#textNodes()
  jni$_.JString? text() {
    return _text(
      reference.pointer,
      _id_text as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_wholeText = _class.instanceMethodId(
    r'wholeText',
    r'()Ljava/lang/String;',
  );

  static final _wholeText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String wholeText()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the non-normalized, decoded text of this element and its children, including only any newlines and spaces
  ///     present in the original source.
  ///@return decoded, non-normalized text
  ///@see \#text()
  ///@see \#wholeOwnText()
  jni$_.JString? wholeText() {
    return _wholeText(
      reference.pointer,
      _id_wholeText as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_wholeOwnText = _class.instanceMethodId(
    r'wholeOwnText',
    r'()Ljava/lang/String;',
  );

  static final _wholeOwnText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String wholeOwnText()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the non-normalized, decoded text of this element, __not including__ any child elements, including any
  ///     newlines and spaces present in the original source.
  ///@return decoded, non-normalized text that is a direct child of this Element
  ///@see \#text()
  ///@see \#wholeText()
  ///@see \#ownText()
  ///@since 1.15.1
  jni$_.JString? wholeOwnText() {
    return _wholeOwnText(
      reference.pointer,
      _id_wholeOwnText as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_ownText = _class.instanceMethodId(
    r'ownText',
    r'()Ljava/lang/String;',
  );

  static final _ownText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String ownText()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the (normalized) text owned by this element only; does not get the combined text of all children.
  ///
  /// For example, given HTML {@code Hello __there__ now!
  ///}, {@code p.ownText()} returns {@code "Hello now!"},
  /// whereas {@code p.text()} returns {@code "Hello there now!"}.
  /// Note that the text within the {@code b} element is not returned, as it is not a direct child of the {@code p} element.
  ///@return decoded text, or empty string if none.
  ///@see \#text()
  ///@see \#textNodes()
  jni$_.JString? ownText() {
    return _ownText(
      reference.pointer,
      _id_ownText as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_text$1 = _class.instanceMethodId(
    r'text',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _text$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element text(java.lang.String text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the text of this element. Any existing contents (text or elements) will be cleared.
  /// As a special case, for {@code <script>} and {@code <style>} tags, the input text will be treated as data,
  /// not visible text.
  ///
  ///@param text decoded text
  ///@return this element
  Element? text$1(
    jni$_.JString? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _text$1(
      reference.pointer,
      _id_text$1 as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_hasText = _class.instanceMethodId(
    r'hasText',
    r'()Z',
  );

  static final _hasText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasText()`
  ///
  /// Checks if the current element or any of its child elements contain non-whitespace text.
  ///@return {@code true} if the element has non-blank text content, {@code false} otherwise.
  bool hasText() {
    return _hasText(
      reference.pointer,
      _id_hasText as jni$_.JMethodIDPtr,
    ).boolean;
  }

  static final _id_data = _class.instanceMethodId(
    r'data',
    r'()Ljava/lang/String;',
  );

  static final _data =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String data()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the combined data of this element. Data is e.g. the inside of a {@code <script>} tag. Note that data is NOT the
  /// text of the element. Use \#text() to get the text that would be visible to a user, and {@code data()}
  /// for the contents of scripts, comments, CSS styles, etc.
  ///@return the data, or empty string if none
  ///@see \#dataNodes()
  jni$_.JString? data() {
    return _data(
      reference.pointer,
      _id_data as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_className = _class.instanceMethodId(
    r'className',
    r'()Ljava/lang/String;',
  );

  static final _className =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String className()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Gets the literal value of this element's "class" attribute, which may include multiple class names, space
  /// separated. (E.g. on <code>&lt;div class="header gray"&gt;</code> returns, "<code>header gray</code>")
  ///@return The literal class attribute, or __empty string__ if no class attribute set.
  jni$_.JString? className() {
    return _className(
      reference.pointer,
      _id_className as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_classNames = _class.instanceMethodId(
    r'classNames',
    r'()Ljava/util/Set;',
  );

  static final _classNames =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.Set<java.lang.String> classNames()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the element's class names. E.g. on element {@code <div class="header gray">},
  /// returns a set of two elements {@code "header", "gray"}. Note that modifications to this set are not pushed to
  /// the backing {@code class} attribute; use the \#classNames(java.util.Set) method to persist them.
  ///@return set of classnames, empty if no class attribute
  jni$_.JSet<jni$_.JString?>? classNames() {
    return _classNames(
      reference.pointer,
      _id_classNames as jni$_.JMethodIDPtr,
    ).object<jni$_.JSet<jni$_.JString?>?>(
      const jni$_.$JSet$NullableType$<jni$_.JString?>(
        jni$_.$JString$NullableType$(),
      ),
    );
  }

  static final _id_classNames$1 = _class.instanceMethodId(
    r'classNames',
    r'(Ljava/util/Set;)Lorg/jsoup/nodes/Element;',
  );

  static final _classNames$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element classNames(java.util.Set<java.lang.String> classNames)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the element's {@code class} attribute to the supplied class names.
  ///@param classNames set of classes
  ///@return this element, for chaining
  Element? classNames$1(
    jni$_.JSet<jni$_.JString?>? classNames,
  ) {
    final _$classNames = classNames?.reference ?? jni$_.jNullReference;
    return _classNames$1(
      reference.pointer,
      _id_classNames$1 as jni$_.JMethodIDPtr,
      _$classNames.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_hasClass = _class.instanceMethodId(
    r'hasClass',
    r'(Ljava/lang/String;)Z',
  );

  static final _hasClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public boolean hasClass(java.lang.String className)`
  ///
  /// Tests if this element has a class. Case-insensitive.
  ///@param className name of class to check for
  ///@return true if it does, false if not
  bool hasClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _hasClass(
      reference.pointer,
      _id_hasClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).boolean;
  }

  static final _id_addClass = _class.instanceMethodId(
    r'addClass',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _addClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element addClass(java.lang.String className)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add a class name to this element's {@code class} attribute.
  ///@param className class name to add
  ///@return this element
  Element? addClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _addClass(
      reference.pointer,
      _id_addClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_removeClass = _class.instanceMethodId(
    r'removeClass',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _removeClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element removeClass(java.lang.String className)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove a class name from this element's {@code class} attribute.
  ///@param className class name to remove
  ///@return this element
  Element? removeClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _removeClass(
      reference.pointer,
      _id_removeClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_toggleClass = _class.instanceMethodId(
    r'toggleClass',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _toggleClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element toggleClass(java.lang.String className)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Toggle a class name on this element's {@code class} attribute: if present, remove it; otherwise add it.
  ///@param className class name to toggle
  ///@return this element
  Element? toggleClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _toggleClass(
      reference.pointer,
      _id_toggleClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_val = _class.instanceMethodId(
    r'val',
    r'()Ljava/lang/String;',
  );

  static final _val =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String val()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the value of a form element (input, textarea, etc).
  ///@return the value of the form element, or empty string if not set.
  jni$_.JString? val() {
    return _val(
      reference.pointer,
      _id_val as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_val$1 = _class.instanceMethodId(
    r'val',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _val$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element val(java.lang.String value)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the value of a form element (input, textarea, etc).
  ///@param value value to set
  ///@return this element (for chaining)
  Element? val$1(
    jni$_.JString? value,
  ) {
    final _$value = value?.reference ?? jni$_.jNullReference;
    return _val$1(
      reference.pointer,
      _id_val$1 as jni$_.JMethodIDPtr,
      _$value.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_endSourceRange = _class.instanceMethodId(
    r'endSourceRange',
    r'()Lorg/jsoup/nodes/Range;',
  );

  static final _endSourceRange =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Range endSourceRange()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the source range (start and end positions) of the end (closing) tag for this Element. Position tracking must be
  ///     enabled prior to parsing the content.
  ///@return the range of the closing tag for this element, or {@code untracked} if its range was not tracked.
  ///@see org.jsoup.parser.Parser\#setTrackPosition(boolean)
  ///@see Node\#sourceRange()
  ///@see Range\#isImplicit()
  ///@since 1.15.2
  jni$_.JObject? endSourceRange() {
    return _endSourceRange(
      reference.pointer,
      _id_endSourceRange as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_html$1 = _class.instanceMethodId(
    r'html',
    r'()Ljava/lang/String;',
  );

  static final _html$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String html()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Retrieves the element's inner HTML. E.g. on a {@code <div>} with one empty {@code }, would return
  /// {@code
  ///}. (Whereas \#outerHtml() would return {@code <div>
  ///</div>}.)
  ///@return String of HTML.
  ///@see \#outerHtml()
  jni$_.JString? html$1() {
    return _html$1(
      reference.pointer,
      _id_html$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_html = _class.instanceMethodId(
    r'html',
    r'(Ljava/lang/Appendable;)Ljava/lang/Appendable;',
  );

  static final _html =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public T html(T appendable)`
  /// The returned object must be released after use, by calling the [release] method.
  $T? html<$T extends jni$_.JObject?>(
    $T? appendable, {
    required jni$_.JType<$T> T,
  }) {
    final _$appendable = appendable?.reference ?? jni$_.jNullReference;
    return _html(
      reference.pointer,
      _id_html as jni$_.JMethodIDPtr,
      _$appendable.pointer,
    ).object<$T?>(T.nullableType);
  }

  static final _id_html$2 = _class.instanceMethodId(
    r'html',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _html$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element html(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set this element's inner HTML. Clears the existing HTML first.
  ///@param html HTML to parse and set into this element
  ///@return this element
  ///@see \#append(String)
  Element? html$2(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _html$2(
      reference.pointer,
      _id_html$2 as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_clone$1 = _class.instanceMethodId(
    r'clone',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _clone$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element clone()`
  /// The returned object must be released after use, by calling the [release] method.
  Element? clone$1() {
    return _clone$1(
      reference.pointer,
      _id_clone$1 as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_shallowClone$1 = _class.instanceMethodId(
    r'shallowClone',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _shallowClone$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element shallowClone()`
  /// The returned object must be released after use, by calling the [release] method.
  Element? shallowClone$1() {
    return _shallowClone$1(
      reference.pointer,
      _id_shallowClone$1 as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_clearAttributes$1 = _class.instanceMethodId(
    r'clearAttributes',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _clearAttributes$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element clearAttributes()`
  /// The returned object must be released after use, by calling the [release] method.
  Element? clearAttributes$1() {
    return _clearAttributes$1(
      reference.pointer,
      _id_clearAttributes$1 as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_removeAttr$1 = _class.instanceMethodId(
    r'removeAttr',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Element;',
  );

  static final _removeAttr$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element removeAttr(java.lang.String attributeKey)`
  /// The returned object must be released after use, by calling the [release] method.
  Element? removeAttr$1(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _removeAttr$1(
      reference.pointer,
      _id_removeAttr$1 as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_root$1 = _class.instanceMethodId(
    r'root',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _root$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element root()`
  /// The returned object must be released after use, by calling the [release] method.
  Element? root$1() {
    return _root$1(
      reference.pointer,
      _id_root$1 as jni$_.JMethodIDPtr,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_traverse$1 = _class.instanceMethodId(
    r'traverse',
    r'(Lorg/jsoup/select/NodeVisitor;)Lorg/jsoup/nodes/Element;',
  );

  static final _traverse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element traverse(org.jsoup.select.NodeVisitor nodeVisitor)`
  /// The returned object must be released after use, by calling the [release] method.
  Element? traverse$1(
    jni$_.JObject? nodeVisitor,
  ) {
    final _$nodeVisitor = nodeVisitor?.reference ?? jni$_.jNullReference;
    return _traverse$1(
      reference.pointer,
      _id_traverse$1 as jni$_.JMethodIDPtr,
      _$nodeVisitor.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_forEachNode$1 = _class.instanceMethodId(
    r'forEachNode',
    r'(Ljava/util/function/Consumer;)Lorg/jsoup/nodes/Element;',
  );

  static final _forEachNode$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element forEachNode(java.util.function.Consumer<? super org.jsoup.nodes.Node> action)`
  /// The returned object must be released after use, by calling the [release] method.
  Element? forEachNode$1(
    jni$_.JObject? action,
  ) {
    final _$action = action?.reference ?? jni$_.jNullReference;
    return _forEachNode$1(
      reference.pointer,
      _id_forEachNode$1 as jni$_.JMethodIDPtr,
      _$action.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_forEach = _class.instanceMethodId(
    r'forEach',
    r'(Ljava/util/function/Consumer;)Lorg/jsoup/nodes/Element;',
  );

  static final _forEach =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element forEach(java.util.function.Consumer<? super org.jsoup.nodes.Element> action)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Perform the supplied action on this Element and each of its descendant Elements, during a depth-first traversal.
  ///     Elements may be inspected, changed, added, replaced, or removed.
  ///@param action the function to perform on the element
  ///@return this Element, for chaining
  ///@see Node\#forEachNode(Consumer)
  ///@deprecated use \#stream().Stream\#forEach(Consumer) forEach(Consumer) instead. (Removing this method
  ///     so Element can implement Iterable, which this signature conflicts with due to the non-void return.)
  Element? forEach(
    jni$_.JObject? action,
  ) {
    final _$action = action?.reference ?? jni$_.jNullReference;
    return _forEach(
      reference.pointer,
      _id_forEach as jni$_.JMethodIDPtr,
      _$action.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }

  static final _id_filter$1 = _class.instanceMethodId(
    r'filter',
    r'(Lorg/jsoup/select/NodeFilter;)Lorg/jsoup/nodes/Element;',
  );

  static final _filter$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.nodes.Element filter(org.jsoup.select.NodeFilter nodeFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  Element? filter$1(
    jni$_.JObject? nodeFilter,
  ) {
    final _$nodeFilter = nodeFilter?.reference ?? jni$_.jNullReference;
    return _filter$1(
      reference.pointer,
      _id_filter$1 as jni$_.JMethodIDPtr,
      _$nodeFilter.pointer,
    ).object<Element?>(const $Element$NullableType$());
  }
}

final class $Element$NullableType$ extends jni$_.JType<Element?> {
  @jni$_.internal
  const $Element$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Element;';

  @jni$_.internal
  @core$_.override
  Element? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Element.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const node$_.$Node$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Element?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Element$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Element$NullableType$) && other is $Element$NullableType$;
  }
}

final class $Element$Type$ extends jni$_.JType<Element> {
  @jni$_.internal
  const $Element$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/Element;';

  @jni$_.internal
  @core$_.override
  Element fromReference(jni$_.JReference reference) => Element.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const node$_.$Node$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Element?> get nullableType => const $Element$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 2;

  @core$_.override
  int get hashCode => ($Element$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Element$Type$) && other is $Element$Type$;
  }
}
