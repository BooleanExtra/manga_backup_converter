// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import 'nodes/Document.dart' as document$_;

/// from: `org.jsoup.Jsoup`
///
/// The core public access point to the jsoup functionality.
///@author Jonathan Hedley
class Jsoup extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Jsoup> $type;

  @jni$_.internal
  Jsoup.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/jsoup/Jsoup');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Jsoup?> nullableType = $Jsoup$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Jsoup> type = $Jsoup$Type$();
  static final _id_parse = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.lang.String html, java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse HTML into a Document. The parser will make a sensible, balanced document tree out of any HTML.
  ///@param html HTML to parse
  ///@param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
  ///     before the HTML declares a {@code <base href>} tag.
  ///@return sane HTML
  static document$_.Document? parse(
    jni$_.JString? html,
    jni$_.JString? baseUri,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return _parse(
      _class.reference.pointer,
      _id_parse as jni$_.JMethodIDPtr,
      _$html.pointer,
      _$baseUri.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$1 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.lang.String html, java.lang.String baseUri, org.jsoup.parser.Parser parser)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML
  ///     (non-HTML) parser.
  ///@param html HTML to parse
  ///@param baseUri The URL where the HTML was retrieved from. Used to resolve relative URLs to absolute URLs, that occur
  ///     before the HTML declares a {@code <base href>} tag.
  ///@param parser alternate Parser\#xmlParser() parser to use.
  ///@return sane HTML
  static document$_.Document? parse$1(
    jni$_.JString? html,
    jni$_.JString? baseUri,
    jni$_.JObject? parser,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    final _$parser = parser?.reference ?? jni$_.jNullReference;
    return _parse$1(
      _class.reference.pointer,
      _id_parse$1 as jni$_.JMethodIDPtr,
      _$html.pointer,
      _$baseUri.pointer,
      _$parser.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$2 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.lang.String html, org.jsoup.parser.Parser parser)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse HTML into a Document, using the provided Parser. You can provide an alternate parser, such as a simple XML
  ///     (non-HTML) parser.  As no base URI is specified, absolute URL resolution, if required, relies on the HTML including
  ///     a {@code <base href>} tag.
  ///@param html HTML to parse
  ///     before the HTML declares a {@code <base href>} tag.
  ///@param parser alternate Parser\#xmlParser() parser to use.
  ///@return sane HTML
  static document$_.Document? parse$2(
    jni$_.JString? html,
    jni$_.JObject? parser,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    final _$parser = parser?.reference ?? jni$_.jNullReference;
    return _parse$2(
      _class.reference.pointer,
      _id_parse$2 as jni$_.JMethodIDPtr,
      _$html.pointer,
      _$parser.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$3 = _class.staticMethodId(
    r'parse',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse HTML into a Document. As no base URI is specified, absolute URL resolution, if required, relies on the HTML
  ///     including a {@code <base href>} tag.
  ///@param html HTML to parse
  ///@return sane HTML
  ///@see \#parse(String, String)
  static document$_.Document? parse$3(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _parse$3(
      _class.reference.pointer,
      _id_parse$3 as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_connect = _class.staticMethodId(
    r'connect',
    r'(Ljava/lang/String;)Lorg/jsoup/Connection;',
  );

  static final _connect =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.Connection connect(java.lang.String url)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a new Connection (session), with the defined request URL. Use to fetch and parse a HTML page.
  ///
  /// Use examples:
  /// <ul>
  ///  <li><code>Document doc = Jsoup.connect("http://example.com").userAgent("Mozilla").data("name", "jsoup").get();</code></li>
  ///  <li><code>Document doc = Jsoup.connect("http://example.com").cookie("auth", "token").post();</code></li>
  /// </ul>
  ///@param url URL to connect to. The protocol must be {@code http} or {@code https}.
  ///@return the connection. You can add data, cookies, and headers; set the user-agent, referrer, method; and then execute.
  ///@see \#newSession()
  ///@see Connection\#newRequest()
  static jni$_.JObject? connect(
    jni$_.JString? url,
  ) {
    final _$url = url?.reference ?? jni$_.jNullReference;
    return _connect(
      _class.reference.pointer,
      _id_connect as jni$_.JMethodIDPtr,
      _$url.pointer,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_newSession = _class.staticMethodId(
    r'newSession',
    r'()Lorg/jsoup/Connection;',
  );

  static final _newSession =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `static public org.jsoup.Connection newSession()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a new Connection to use as a session. Connection settings (user-agent, timeouts, URL, etc), and
  ///     cookies will be maintained for the session. Use examples:
  ///<pre><code>
  ///Connection session = Jsoup.newSession()
  ///     .timeout(20 * 1000)
  ///     .userAgent("FooBar 2000");
  ///
  ///Document doc1 = session.newRequest()
  ///     .url("https://jsoup.org/").data("ref", "example")
  ///     .get();
  ///Document doc2 = session.newRequest()
  ///     .url("https://en.wikipedia.org/wiki/Main_Page")
  ///     .get();
  ///Connection con3 = session.newRequest();
  ///</code></pre>
  ///
  ///     For multi-threaded requests, it is safe to use this session between threads, but take care to call Connection\#newRequest() per request and not share that instance between threads when executing or parsing.
  ///
  ///@return a connection
  ///@since 1.14.1
  static jni$_.JObject? newSession() {
    return _newSession(
      _class.reference.pointer,
      _id_newSession as jni$_.JMethodIDPtr,
    ).object<jni$_.JObject?>(const jni$_.$JObject$NullableType$());
  }

  static final _id_parse$4 = _class.staticMethodId(
    r'parse',
    r'(Ljava/io/File;Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.io.File file, java.lang.String charsetName, java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML.
  ///@param file file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@param baseUri The URL where the HTML was retrieved from, to resolve relative links against.
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  static document$_.Document? parse$4(
    jni$_.JObject? file,
    jni$_.JString? charsetName,
    jni$_.JString? baseUri,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return _parse$4(
      _class.reference.pointer,
      _id_parse$4 as jni$_.JMethodIDPtr,
      _$file.pointer,
      _$charsetName.pointer,
      _$baseUri.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$5 = _class.staticMethodId(
    r'parse',
    r'(Ljava/io/File;Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$5 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.io.File file, java.lang.String charsetName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
  ///@param file file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  ///@see \#parse(File, String, String) parse(file, charset, baseUri)
  static document$_.Document? parse$5(
    jni$_.JObject? file,
    jni$_.JString? charsetName,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    return _parse$5(
      _class.reference.pointer,
      _id_parse$5 as jni$_.JMethodIDPtr,
      _$file.pointer,
      _$charsetName.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$6 = _class.staticMethodId(
    r'parse',
    r'(Ljava/io/File;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$6 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.io.File file)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
  ///     The charset used to read the file will be determined by the byte-order-mark (BOM), or a {@code <meta charset>} tag,
  ///     or if neither is present, will be {@code UTF-8}.
  ///
  ///     This is the equivalent of calling \#parse(File, String) parse(file, null)
  ///
  ///@param file the file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@return sane HTML
  ///@throws IOException if the file could not be found or read.
  ///@see \#parse(File, String, String) parse(file, charset, baseUri)
  ///@since 1.15.1
  static document$_.Document? parse$6(
    jni$_.JObject? file,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    return _parse$6(
      _class.reference.pointer,
      _id_parse$6 as jni$_.JMethodIDPtr,
      _$file.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$7 = _class.staticMethodId(
    r'parse',
    r'(Ljava/io/File;Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$7 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.io.File file, java.lang.String charsetName, java.lang.String baseUri, org.jsoup.parser.Parser parser)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML.
  ///@param file file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@param baseUri The URL where the HTML was retrieved from, to resolve relative links against.
  ///@param parser alternate Parser\#xmlParser() parser to use.
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  ///@since 1.14.2
  static document$_.Document? parse$7(
    jni$_.JObject? file,
    jni$_.JString? charsetName,
    jni$_.JString? baseUri,
    jni$_.JObject? parser,
  ) {
    final _$file = file?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    final _$parser = parser?.reference ?? jni$_.jNullReference;
    return _parse$7(
      _class.reference.pointer,
      _id_parse$7 as jni$_.JMethodIDPtr,
      _$file.pointer,
      _$charsetName.pointer,
      _$baseUri.pointer,
      _$parser.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$8 = _class.staticMethodId(
    r'parse',
    r'(Ljava/nio/file/Path;Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$8 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.nio.file.Path path, java.lang.String charsetName, java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML.
  ///@param path file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@param baseUri The URL where the HTML was retrieved from, to resolve relative links against.
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  ///@since 1.18.1
  static document$_.Document? parse$8(
    jni$_.JObject? path,
    jni$_.JString? charsetName,
    jni$_.JString? baseUri,
  ) {
    final _$path = path?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return _parse$8(
      _class.reference.pointer,
      _id_parse$8 as jni$_.JMethodIDPtr,
      _$path.pointer,
      _$charsetName.pointer,
      _$baseUri.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$9 = _class.staticMethodId(
    r'parse',
    r'(Ljava/nio/file/Path;Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$9 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.nio.file.Path path, java.lang.String charsetName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
  ///@param path file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  ///@see \#parse(File, String, String) parse(file, charset, baseUri)
  ///@since 1.18.1
  static document$_.Document? parse$9(
    jni$_.JObject? path,
    jni$_.JString? charsetName,
  ) {
    final _$path = path?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    return _parse$9(
      _class.reference.pointer,
      _id_parse$9 as jni$_.JMethodIDPtr,
      _$path.pointer,
      _$charsetName.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$10 = _class.staticMethodId(
    r'parse',
    r'(Ljava/nio/file/Path;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$10 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.nio.file.Path path)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML. The location of the file is used as the base URI to qualify relative URLs.
  ///     The charset used to read the file will be determined by the byte-order-mark (BOM), or a {@code <meta charset>} tag,
  ///     or if neither is present, will be {@code UTF-8}.
  ///
  ///     This is the equivalent of calling \#parse(File, String) parse(file, null)
  ///
  ///@param path the file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@return sane HTML
  ///@throws IOException if the file could not be found or read.
  ///@see \#parse(Path, String, String) parse(file, charset, baseUri)
  ///@since 1.18.1
  static document$_.Document? parse$10(
    jni$_.JObject? path,
  ) {
    final _$path = path?.reference ?? jni$_.jNullReference;
    return _parse$10(
      _class.reference.pointer,
      _id_parse$10 as jni$_.JMethodIDPtr,
      _$path.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$11 = _class.staticMethodId(
    r'parse',
    r'(Ljava/nio/file/Path;Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$11 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.nio.file.Path path, java.lang.String charsetName, java.lang.String baseUri, org.jsoup.parser.Parser parser)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse the contents of a file as HTML.
  ///@param path file to load HTML from. Supports gzipped files (ending in .z or .gz).
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@param baseUri The URL where the HTML was retrieved from, to resolve relative links against.
  ///@param parser alternate Parser\#xmlParser() parser to use.
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  ///@since 1.18.1
  static document$_.Document? parse$11(
    jni$_.JObject? path,
    jni$_.JString? charsetName,
    jni$_.JString? baseUri,
    jni$_.JObject? parser,
  ) {
    final _$path = path?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    final _$parser = parser?.reference ?? jni$_.jNullReference;
    return _parse$11(
      _class.reference.pointer,
      _id_parse$11 as jni$_.JMethodIDPtr,
      _$path.pointer,
      _$charsetName.pointer,
      _$baseUri.pointer,
      _$parser.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$12 = _class.staticMethodId(
    r'parse',
    r'(Ljava/io/InputStream;Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$12 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.io.InputStream in, java.lang.String charsetName, java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Read an input stream, and parse it to a Document.
  ///@param in input stream to read. The stream will be closed after reading.
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@param baseUri The URL where the HTML was retrieved from, to resolve relative links against.
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  static document$_.Document? parse$12(
    jni$_.JObject? in$,
    jni$_.JString? charsetName,
    jni$_.JString? baseUri,
  ) {
    final _$in$ = in$?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return _parse$12(
      _class.reference.pointer,
      _id_parse$12 as jni$_.JMethodIDPtr,
      _$in$.pointer,
      _$charsetName.pointer,
      _$baseUri.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$13 = _class.staticMethodId(
    r'parse',
    r'(Ljava/io/InputStream;Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/parser/Parser;)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$13 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.io.InputStream in, java.lang.String charsetName, java.lang.String baseUri, org.jsoup.parser.Parser parser)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Read an input stream, and parse it to a Document. You can provide an alternate parser, such as a simple XML
  ///     (non-HTML) parser.
  ///@param in input stream to read. Make sure to close it after parsing.
  ///@param charsetName (optional) character set of file contents. Set to {@code null} to determine from {@code http-equiv} meta tag, if
  ///     present, or fall back to {@code UTF-8} (which is often safe to do).
  ///@param baseUri The URL where the HTML was retrieved from, to resolve relative links against.
  ///@param parser alternate Parser\#xmlParser() parser to use.
  ///@return sane HTML
  ///@throws IOException if the file could not be found, or read, or if the charsetName is invalid.
  static document$_.Document? parse$13(
    jni$_.JObject? in$,
    jni$_.JString? charsetName,
    jni$_.JString? baseUri,
    jni$_.JObject? parser,
  ) {
    final _$in$ = in$?.reference ?? jni$_.jNullReference;
    final _$charsetName = charsetName?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    final _$parser = parser?.reference ?? jni$_.jNullReference;
    return _parse$13(
      _class.reference.pointer,
      _id_parse$13 as jni$_.JMethodIDPtr,
      _$in$.pointer,
      _$charsetName.pointer,
      _$baseUri.pointer,
      _$parser.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parseBodyFragment = _class.staticMethodId(
    r'parseBodyFragment',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parseBodyFragment =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parseBodyFragment(java.lang.String bodyHtml, java.lang.String baseUri)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.
  ///@param bodyHtml body HTML fragment
  ///@param baseUri URL to resolve relative URLs against.
  ///@return sane HTML document
  ///@see Document\#body()
  static document$_.Document? parseBodyFragment(
    jni$_.JString? bodyHtml,
    jni$_.JString? baseUri,
  ) {
    final _$bodyHtml = bodyHtml?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    return _parseBodyFragment(
      _class.reference.pointer,
      _id_parseBodyFragment as jni$_.JMethodIDPtr,
      _$bodyHtml.pointer,
      _$baseUri.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parseBodyFragment$1 = _class.staticMethodId(
    r'parseBodyFragment',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/Document;',
  );

  static final _parseBodyFragment$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parseBodyFragment(java.lang.String bodyHtml)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Parse a fragment of HTML, with the assumption that it forms the {@code body} of the HTML.
  ///@param bodyHtml body HTML fragment
  ///@return sane HTML document
  ///@see Document\#body()
  static document$_.Document? parseBodyFragment$1(
    jni$_.JString? bodyHtml,
  ) {
    final _$bodyHtml = bodyHtml?.reference ?? jni$_.jNullReference;
    return _parseBodyFragment$1(
      _class.reference.pointer,
      _id_parseBodyFragment$1 as jni$_.JMethodIDPtr,
      _$bodyHtml.pointer,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_parse$14 = _class.staticMethodId(
    r'parse',
    r'(Ljava/net/URL;I)Lorg/jsoup/nodes/Document;',
  );

  static final _parse$14 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Int32)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              int,
            )
          >();

  /// from: `static public org.jsoup.nodes.Document parse(java.net.URL url, int timeoutMillis)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Fetch a URL, and parse it as HTML. Provided for compatibility; in most cases use \#connect(String) instead.
  ///
  ///     The encoding character set is determined by the content-type header or http-equiv meta tag, or falls back to {@code UTF-8}.
  ///@param url URL to fetch (with a GET). The protocol must be {@code http} or {@code https}.
  ///@param timeoutMillis Connection and read timeout, in milliseconds. If exceeded, IOException is thrown.
  ///@return The parsed HTML.
  ///@throws java.net.MalformedURLException if the request URL is not a HTTP or HTTPS URL, or is otherwise malformed
  ///@throws HttpStatusException if the response is not OK and HTTP response errors are not ignored
  ///@throws UnsupportedMimeTypeException if the response mime type is not supported and those errors are not ignored
  ///@throws java.net.SocketTimeoutException if the connection times out
  ///@throws IOException if a connection or read error occurs
  ///@see \#connect(String)
  static document$_.Document? parse$14(
    jni$_.JObject? url,
    int timeoutMillis,
  ) {
    final _$url = url?.reference ?? jni$_.jNullReference;
    return _parse$14(
      _class.reference.pointer,
      _id_parse$14 as jni$_.JMethodIDPtr,
      _$url.pointer,
      timeoutMillis,
    ).object<document$_.Document?>(const document$_.$Document$NullableType$());
  }

  static final _id_clean = _class.staticMethodId(
    r'clean',
    r'(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/safety/Safelist;)Ljava/lang/String;',
  );

  static final _clean =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String clean(java.lang.String bodyHtml, java.lang.String baseUri, org.jsoup.safety.Safelist safelist)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through an allow-list of safe
  ///     tags and attributes.
  ///@param bodyHtml input untrusted HTML (body fragment)
  ///@param baseUri URL to resolve relative URLs against
  ///@param safelist list of permitted HTML elements
  ///@return safe HTML (body fragment)
  ///@see Cleaner\#clean(Document)
  static jni$_.JString? clean(
    jni$_.JString? bodyHtml,
    jni$_.JString? baseUri,
    jni$_.JObject? safelist,
  ) {
    final _$bodyHtml = bodyHtml?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    final _$safelist = safelist?.reference ?? jni$_.jNullReference;
    return _clean(
      _class.reference.pointer,
      _id_clean as jni$_.JMethodIDPtr,
      _$bodyHtml.pointer,
      _$baseUri.pointer,
      _$safelist.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_clean$1 = _class.staticMethodId(
    r'clean',
    r'(Ljava/lang/String;Lorg/jsoup/safety/Safelist;)Ljava/lang/String;',
  );

  static final _clean$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String clean(java.lang.String bodyHtml, org.jsoup.safety.Safelist safelist)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of permitted
  ///     tags and attributes.
  ///
  ///     Note that as this method does not take a base href URL to resolve attributes with relative URLs against, those
  ///     URLs will be removed, unless the input HTML contains a {@code <base href> tag}. If you wish to preserve those, use
  ///     the Jsoup\#clean(String html, String baseHref, Safelist) method instead, and enable
  ///     Safelist\#preserveRelativeLinks(boolean).
  ///
  ///
  ///     Note that the output of this method is still __HTML__ even when using the TextNode only
  ///     Safelist\#none(), and so any HTML entities in the output will be appropriately escaped.
  ///     If you want plain text, not HTML, you should use a text method such as Element\#text() instead, after
  ///     cleaning the document.
  ///
  ///     Example:
  ///
  ///     <pre>{@code
  ///     String sourceBodyHtml = "5 is &lt; 6.
  ///";
  ///     String html = Jsoup.clean(sourceBodyHtml, Safelist.none());
  ///
  ///     Cleaner cleaner = new Cleaner(Safelist.none());
  ///     String text = cleaner.clean(Jsoup.parse(sourceBodyHtml)).text();
  ///
  ///     // html is: 5 is &lt; 6.
  ///     // text is: 5 is < 6.
  ///     }</pre>
  ///@param bodyHtml input untrusted HTML (body fragment)
  ///@param safelist list of permitted HTML elements
  ///@return safe HTML (body fragment)
  ///@see Cleaner\#clean(Document)
  static jni$_.JString? clean$1(
    jni$_.JString? bodyHtml,
    jni$_.JObject? safelist,
  ) {
    final _$bodyHtml = bodyHtml?.reference ?? jni$_.jNullReference;
    final _$safelist = safelist?.reference ?? jni$_.jNullReference;
    return _clean$1(
      _class.reference.pointer,
      _id_clean$1 as jni$_.JMethodIDPtr,
      _$bodyHtml.pointer,
      _$safelist.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_clean$2 = _class.staticMethodId(
    r'clean',
    r'(Ljava/lang/String;Ljava/lang/String;Lorg/jsoup/safety/Safelist;Lorg/jsoup/nodes/Document$OutputSettings;)Ljava/lang/String;',
  );

  static final _clean$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                    jni$_.Pointer<jni$_.Void>,
                  )
                >,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public java.lang.String clean(java.lang.String bodyHtml, java.lang.String baseUri, org.jsoup.safety.Safelist safelist, org.jsoup.nodes.Document$OutputSettings outputSettings)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get safe HTML from untrusted input HTML, by parsing input HTML and filtering it through a safe-list of
  /// permitted tags and attributes.
  /// The HTML is treated as a body fragment; it's expected the cleaned HTML will be used within the body of an
  /// existing document. If you want to clean full documents, use Cleaner\#clean(Document) instead, and add
  /// structural tags (<code>html, head, body</code> etc) to the safelist.
  ///@param bodyHtml input untrusted HTML (body fragment)
  ///@param baseUri URL to resolve relative URLs against
  ///@param safelist list of permitted HTML elements
  ///@param outputSettings document output settings; use to control pretty-printing and entity escape modes
  ///@return safe HTML (body fragment)
  ///@see Cleaner\#clean(Document)
  static jni$_.JString? clean$2(
    jni$_.JString? bodyHtml,
    jni$_.JString? baseUri,
    jni$_.JObject? safelist,
    document$_.Document$OutputSettings? outputSettings,
  ) {
    final _$bodyHtml = bodyHtml?.reference ?? jni$_.jNullReference;
    final _$baseUri = baseUri?.reference ?? jni$_.jNullReference;
    final _$safelist = safelist?.reference ?? jni$_.jNullReference;
    final _$outputSettings = outputSettings?.reference ?? jni$_.jNullReference;
    return _clean$2(
      _class.reference.pointer,
      _id_clean$2 as jni$_.JMethodIDPtr,
      _$bodyHtml.pointer,
      _$baseUri.pointer,
      _$safelist.pointer,
      _$outputSettings.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_isValid = _class.staticMethodId(
    r'isValid',
    r'(Ljava/lang/String;Lorg/jsoup/safety/Safelist;)Z',
  );

  static final _isValid =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<
                  (jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)
                >,
              )
            >
          >('globalEnv_CallStaticBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `static public boolean isValid(java.lang.String bodyHtml, org.jsoup.safety.Safelist safelist)`
  ///
  /// Test if the input body HTML has only tags and attributes allowed by the Safelist. Useful for form validation.
  ///
  ///     This method is intended to be used in a user interface as a validator for user input. Note that regardless of the
  ///     output of this method, the input document __must always__ be normalized using a method such as
  ///     \#clean(String, String, Safelist), and the result of that method used to store or serialize the document
  ///     before later reuse such as presentation to end users. This ensures that enforced attributes are set correctly, and
  ///     that any differences between how a given browser and how jsoup parses the input HTML are normalized.
  ///
  ///
  ///     Example:
  ///
  ///     <pre>{@code
  ///     Safelist safelist = Safelist.relaxed();
  ///     boolean isValid = Jsoup.isValid(sourceBodyHtml, safelist);
  ///     String normalizedHtml = Jsoup.clean(sourceBodyHtml, "https://example.com/", safelist);
  ///     }</pre>
  ///     Assumes the HTML is a body fragment (i.e. will be used in an existing HTML document body.)
  ///@param bodyHtml HTML to test
  ///@param safelist safelist to test against
  ///@return true if no tags or attributes were removed; false otherwise
  ///@see \#clean(String, Safelist)
  static bool isValid(
    jni$_.JString? bodyHtml,
    jni$_.JObject? safelist,
  ) {
    final _$bodyHtml = bodyHtml?.reference ?? jni$_.jNullReference;
    final _$safelist = safelist?.reference ?? jni$_.jNullReference;
    return _isValid(
      _class.reference.pointer,
      _id_isValid as jni$_.JMethodIDPtr,
      _$bodyHtml.pointer,
      _$safelist.pointer,
    ).boolean;
  }
}

final class $Jsoup$NullableType$ extends jni$_.JType<Jsoup?> {
  @jni$_.internal
  const $Jsoup$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/Jsoup;';

  @jni$_.internal
  @core$_.override
  Jsoup? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Jsoup.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Jsoup?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Jsoup$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Jsoup$NullableType$) &&
        other is $Jsoup$NullableType$;
  }
}

final class $Jsoup$Type$ extends jni$_.JType<Jsoup> {
  @jni$_.internal
  const $Jsoup$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/Jsoup;';

  @jni$_.internal
  @core$_.override
  Jsoup fromReference(jni$_.JReference reference) => Jsoup.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Jsoup?> get nullableType => const $Jsoup$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Jsoup$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Jsoup$Type$) && other is $Jsoup$Type$;
  }
}
