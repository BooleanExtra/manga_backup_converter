// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

import '../nodes/Element.dart' as element$_;

import '../nodes/TextNode.dart' as textnode$_;

/// from: `org.jsoup.select.Elements`
///
/// A list of Elements, with methods that act on every element in the list.
/// To get an {@code Elements} object, use the Element\#select(String) method.
///
/// Methods that \#set(int, Element) set, \#remove(int) remove, or \#replaceAll(UnaryOperator) replace Elements in the list will also act on the underlying org.jsoup.nodes.Document DOM.
///
///@author Jonathan Hedley, jonathan@hedley.net
class Elements extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<Elements> $type;

  @jni$_.internal
  Elements.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/jsoup/select/Elements');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Elements?> nullableType = $Elements$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<Elements> type = $Elements$Type$();
  static final _id_new$ = _class.constructorId(
    r'()V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void <init>()`
  /// The returned object must be released after use, by calling the [release] method.
  factory Elements() {
    return Elements.fromReference(_new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr).reference);
  }

  static final _id_new$1 = _class.constructorId(
    r'(I)V',
  );

  static final _new$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
            >
          >('globalEnv_NewObject')
          .asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public void <init>(int initialCapacity)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Elements.new$1(
    int initialCapacity,
  ) {
    return Elements.fromReference(
      _new$1(_class.reference.pointer, _id_new$1 as jni$_.JMethodIDPtr, initialCapacity).reference,
    );
  }

  static final _id_new$2 = _class.constructorId(
    r'(Ljava/util/Collection;)V',
  );

  static final _new$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public void <init>(java.util.Collection<org.jsoup.nodes.Element> elements)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Elements.new$2(
    jni$_.JObject? elements,
  ) {
    final _$elements = elements?.reference ?? jni$_.jNullReference;
    return Elements.fromReference(
      _new$2(_class.reference.pointer, _id_new$2 as jni$_.JMethodIDPtr, _$elements.pointer).reference,
    );
  }

  static final _id_new$3 = _class.constructorId(
    r'(Ljava/util/List;)V',
  );

  static final _new$3 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public void <init>(java.util.List<org.jsoup.nodes.Element> elements)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Elements.new$3(
    jni$_.JList<element$_.Element?>? elements,
  ) {
    final _$elements = elements?.reference ?? jni$_.jNullReference;
    return Elements.fromReference(
      _new$3(_class.reference.pointer, _id_new$3 as jni$_.JMethodIDPtr, _$elements.pointer).reference,
    );
  }

  static final _id_new$4 = _class.constructorId(
    r'([Lorg/jsoup/nodes/Element;)V',
  );

  static final _new$4 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public void <init>(org.jsoup.nodes.Element[] elements)`
  /// The returned object must be released after use, by calling the [release] method.
  factory Elements.new$4(
    jni$_.JArray<element$_.Element?>? elements,
  ) {
    final _$elements = elements?.reference ?? jni$_.jNullReference;
    return Elements.fromReference(
      _new$4(_class.reference.pointer, _id_new$4 as jni$_.JMethodIDPtr, _$elements.pointer).reference,
    );
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements clone()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Creates a deep copy of these elements.
  ///@return a deep copy
  Elements? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_attr = _class.instanceMethodId(
    r'attr',
    r'(Ljava/lang/String;)Ljava/lang/String;',
  );

  static final _attr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.lang.String attr(java.lang.String attributeKey)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get an attribute value from the first matched element that has the attribute.
  ///@param attributeKey The attribute key.
  ///@return The attribute value from the first matched element that has the attribute. If no elements were matched (isEmpty() == true),
  ///     or if the no elements have the attribute, returns empty string.
  ///@see \#hasAttr(String)
  jni$_.JString? attr(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _attr(
      reference.pointer,
      _id_attr as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_hasAttr = _class.instanceMethodId(
    r'hasAttr',
    r'(Ljava/lang/String;)Z',
  );

  static final _hasAttr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean hasAttr(java.lang.String attributeKey)`
  ///
  /// Checks if any of the matched elements have this attribute defined.
  ///@param attributeKey attribute key
  ///@return true if any of the elements have the attribute; false if none do.
  bool hasAttr(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _hasAttr(reference.pointer, _id_hasAttr as jni$_.JMethodIDPtr, _$attributeKey.pointer).boolean;
  }

  static final _id_eachAttr = _class.instanceMethodId(
    r'eachAttr',
    r'(Ljava/lang/String;)Ljava/util/List;',
  );

  static final _eachAttr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public java.util.List<java.lang.String> eachAttr(java.lang.String attributeKey)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the attribute value for each of the matched elements. If an element does not have this attribute, no value is
  /// included in the result set for that element.
  ///@param attributeKey the attribute name to return values for. You can add the {@code abs:} prefix to the key to
  /// get absolute URLs from relative URLs, e.g.: {@code doc.select("a").eachAttr("abs:href")} .
  ///@return a list of each element's attribute value for the attribute
  jni$_.JList<jni$_.JString?>? eachAttr(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _eachAttr(
      reference.pointer,
      _id_eachAttr as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(jni$_.$JString$NullableType$()),
    );
  }

  static final _id_attr$1 = _class.instanceMethodId(
    r'attr',
    r'(Ljava/lang/String;Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _attr$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
              jni$_.Pointer<jni$_.Void>,
              jni$_.Pointer<jni$_.Void>,
            )
          >();

  /// from: `public org.jsoup.select.Elements attr(java.lang.String attributeKey, java.lang.String attributeValue)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set an attribute on all matched elements.
  ///@param attributeKey attribute key
  ///@param attributeValue attribute value
  ///@return this
  Elements? attr$1(
    jni$_.JString? attributeKey,
    jni$_.JString? attributeValue,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    final _$attributeValue = attributeValue?.reference ?? jni$_.jNullReference;
    return _attr$1(
      reference.pointer,
      _id_attr$1 as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
      _$attributeValue.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_removeAttr = _class.instanceMethodId(
    r'removeAttr',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _removeAttr =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements removeAttr(java.lang.String attributeKey)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove an attribute from every matched element.
  ///@param attributeKey The attribute to remove.
  ///@return this (for chaining)
  Elements? removeAttr(
    jni$_.JString? attributeKey,
  ) {
    final _$attributeKey = attributeKey?.reference ?? jni$_.jNullReference;
    return _removeAttr(
      reference.pointer,
      _id_removeAttr as jni$_.JMethodIDPtr,
      _$attributeKey.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_addClass = _class.instanceMethodId(
    r'addClass',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _addClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements addClass(java.lang.String className)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add the class name to every matched element's {@code class} attribute.
  ///@param className class name to add
  ///@return this
  Elements? addClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _addClass(
      reference.pointer,
      _id_addClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_removeClass = _class.instanceMethodId(
    r'removeClass',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _removeClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements removeClass(java.lang.String className)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove the class name from every matched element's {@code class} attribute, if present.
  ///@param className class name to remove
  ///@return this
  Elements? removeClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _removeClass(
      reference.pointer,
      _id_removeClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_toggleClass = _class.instanceMethodId(
    r'toggleClass',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _toggleClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements toggleClass(java.lang.String className)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Toggle the class name on every matched element's {@code class} attribute.
  ///@param className class name to add if missing, or remove if present, from every element.
  ///@return this
  Elements? toggleClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _toggleClass(
      reference.pointer,
      _id_toggleClass as jni$_.JMethodIDPtr,
      _$className.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_hasClass = _class.instanceMethodId(
    r'hasClass',
    r'(Ljava/lang/String;)Z',
  );

  static final _hasClass =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean hasClass(java.lang.String className)`
  ///
  /// Determine if any of the matched elements have this class name set in their {@code class} attribute.
  ///@param className class name to check for
  ///@return true if any do, false if none do
  bool hasClass(
    jni$_.JString? className,
  ) {
    final _$className = className?.reference ?? jni$_.jNullReference;
    return _hasClass(reference.pointer, _id_hasClass as jni$_.JMethodIDPtr, _$className.pointer).boolean;
  }

  static final _id_val = _class.instanceMethodId(
    r'val',
    r'()Ljava/lang/String;',
  );

  static final _val =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String val()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the form element's value of the first matched element.
  ///@return The form element's value, or empty if not set.
  ///@see Element\#val()
  jni$_.JString? val() {
    return _val(
      reference.pointer,
      _id_val as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_val$1 = _class.instanceMethodId(
    r'val',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _val$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements val(java.lang.String value)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the form element's value in each of the matched elements.
  ///@param value The value to set into each matched element
  ///@return this (for chaining)
  Elements? val$1(
    jni$_.JString? value,
  ) {
    final _$value = value?.reference ?? jni$_.jNullReference;
    return _val$1(
      reference.pointer,
      _id_val$1 as jni$_.JMethodIDPtr,
      _$value.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_text = _class.instanceMethodId(
    r'text',
    r'()Ljava/lang/String;',
  );

  static final _text =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String text()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the combined text of all the matched elements.
  ///
  /// Note that it is possible to get repeats if the matched elements contain both parent elements and their own
  /// children, as the Element.text() method returns the combined text of a parent and all its children.
  ///@return string of all text: unescaped and no HTML.
  ///@see Element\#text()
  ///@see \#eachText()
  jni$_.JString? text() {
    return _text(
      reference.pointer,
      _id_text as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_hasText = _class.instanceMethodId(
    r'hasText',
    r'()Z',
  );

  static final _hasText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean hasText()`
  ///
  /// Test if any matched Element has any text content, that is not just whitespace.
  ///@return true if any element has non-blank text content.
  ///@see Element\#hasText()
  bool hasText() {
    return _hasText(reference.pointer, _id_hasText as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_eachText = _class.instanceMethodId(
    r'eachText',
    r'()Ljava/util/List;',
  );

  static final _eachText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<java.lang.String> eachText()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the text content of each of the matched elements. If an element has no text, then it is not included in the
  /// result.
  ///@return A list of each matched element's text content.
  ///@see Element\#text()
  ///@see Element\#hasText()
  ///@see \#text()
  jni$_.JList<jni$_.JString?>? eachText() {
    return _eachText(reference.pointer, _id_eachText as jni$_.JMethodIDPtr).object<jni$_.JList<jni$_.JString?>?>(
      const jni$_.$JList$NullableType$<jni$_.JString?>(jni$_.$JString$NullableType$()),
    );
  }

  static final _id_html = _class.instanceMethodId(
    r'html',
    r'()Ljava/lang/String;',
  );

  static final _html =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String html()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the combined inner HTML of all matched elements.
  ///@return string of all element's inner HTML.
  ///@see \#text()
  ///@see \#outerHtml()
  jni$_.JString? html() {
    return _html(
      reference.pointer,
      _id_html as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_outerHtml = _class.instanceMethodId(
    r'outerHtml',
    r'()Ljava/lang/String;',
  );

  static final _outerHtml =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String outerHtml()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the combined outer HTML of all matched elements.
  ///@return string of all element's outer HTML.
  ///@see \#text()
  ///@see \#html()
  jni$_.JString? outerHtml() {
    return _outerHtml(
      reference.pointer,
      _id_outerHtml as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the combined outer HTML of all matched elements. Alias of \#outerHtml().
  ///@return string of all element's outer HTML.
  ///@see \#text()
  ///@see \#html()
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_tagName = _class.instanceMethodId(
    r'tagName',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _tagName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements tagName(java.lang.String tagName)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Update (rename) the tag name of each matched element. For example, to change each {@code <i>} to a {@code _}, do
  /// {@code doc.select("i").tagName("em");}
  ///@param tagName the new tag name
  ///@return this, for chaining
  ///@see Element\#tagName(String)
  Elements? tagName(
    jni$_.JString? tagName,
  ) {
    final _$tagName = tagName?.reference ?? jni$_.jNullReference;
    return _tagName(
      reference.pointer,
      _id_tagName as jni$_.JMethodIDPtr,
      _$tagName.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_html$1 = _class.instanceMethodId(
    r'html',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _html$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements html(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the inner HTML of each matched element.
  ///@param html HTML to parse and set into each matched element.
  ///@return this, for chaining
  ///@see Element\#html(String)
  Elements? html$1(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _html$1(
      reference.pointer,
      _id_html$1 as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_prepend = _class.instanceMethodId(
    r'prepend',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _prepend =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements prepend(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add the supplied HTML to the start of each matched element's inner HTML.
  ///@param html HTML to add inside each element, before the existing HTML
  ///@return this, for chaining
  ///@see Element\#prepend(String)
  Elements? prepend(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _prepend(
      reference.pointer,
      _id_prepend as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_append = _class.instanceMethodId(
    r'append',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _append =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements append(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Add the supplied HTML to the end of each matched element's inner HTML.
  ///@param html HTML to add inside each element, after the existing HTML
  ///@return this, for chaining
  ///@see Element\#append(String)
  Elements? append(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _append(
      reference.pointer,
      _id_append as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_before = _class.instanceMethodId(
    r'before',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _before =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements before(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the supplied HTML before each matched element's outer HTML.
  ///@param html HTML to insert before each element
  ///@return this, for chaining
  ///@see Element\#before(String)
  Elements? before(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _before(
      reference.pointer,
      _id_before as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_after = _class.instanceMethodId(
    r'after',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _after =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements after(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Insert the supplied HTML after each matched element's outer HTML.
  ///@param html HTML to insert after each element
  ///@return this, for chaining
  ///@see Element\#after(String)
  Elements? after(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _after(
      reference.pointer,
      _id_after as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_wrap = _class.instanceMethodId(
    r'wrap',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _wrap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements wrap(java.lang.String html)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Wrap the supplied HTML around each matched elements. For example, with HTML
  ///     {@code __This__ is __Jsoup__
  ///},
  ///     <code>doc.select("b").wrap("&lt;i&gt;&lt;/i&gt;");</code>
  ///     becomes {@code <i>__This__</i> is <i>__jsoup__</i>
  ///}
  ///@param html HTML to wrap around each element, e.g. {@code <div class="head"></div>}. Can be arbitrarily deep.
  ///@return this (for chaining)
  ///@see Element\#wrap
  Elements? wrap(
    jni$_.JString? html,
  ) {
    final _$html = html?.reference ?? jni$_.jNullReference;
    return _wrap(
      reference.pointer,
      _id_wrap as jni$_.JMethodIDPtr,
      _$html.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_unwrap = _class.instanceMethodId(
    r'unwrap',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _unwrap =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements unwrap()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Removes the matched elements from the DOM, and moves their children up into their parents. This has the effect of
  /// dropping the elements but keeping their children.
  ///
  /// This is useful for e.g removing unwanted formatting elements but keeping their contents.
  ///
  ///
  ///
  /// E.g. with HTML: {@code <div><font>One</font> <font><a href="/">Two</a></font></div>}
  ///
  /// {@code doc.select("font").unwrap();}
  ///
  /// HTML = {@code <div>One <a href="/">Two</a></div>}
  ///
  ///@return this (for chaining)
  ///@see Node\#unwrap
  Elements? unwrap() {
    return _unwrap(
      reference.pointer,
      _id_unwrap as jni$_.JMethodIDPtr,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_empty = _class.instanceMethodId(
    r'empty',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _empty =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements empty()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Empty (remove all child nodes from) each matched element. This is similar to setting the inner HTML of each
  /// element to nothing.
  ///
  /// E.g. HTML: {@code <div>Hello __there__
  /// now
  ///</div>}<br>
  /// <code>doc.select("p").empty();</code><br>
  /// HTML = {@code <div>
  ///
  ///</div>}
  ///@return this, for chaining
  ///@see Element\#empty()
  ///@see \#remove()
  Elements? empty() {
    return _empty(
      reference.pointer,
      _id_empty as jni$_.JMethodIDPtr,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_remove = _class.instanceMethodId(
    r'remove',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _remove =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements remove()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove each matched element from the DOM. This is similar to setting the outer HTML of each element to nothing.
  /// The elements will still be retained in this list, in case further processing of them is desired.
  ///
  ///
  /// E.g. HTML: {@code <div>Hello
  /// there
  /// <img /></div>}<br>
  /// <code>doc.select("p").remove();</code><br>
  /// HTML = {@code <div> <img /></div>}
  ///
  /// Note that this method should not be used to clean user-submitted HTML; rather, use org.jsoup.safety.Cleaner to clean HTML.
  ///@return this, for chaining
  ///@see Element\#empty()
  ///@see \#empty()
  ///@see \#clear()
  Elements? remove() {
    return _remove(
      reference.pointer,
      _id_remove as jni$_.JMethodIDPtr,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_select = _class.instanceMethodId(
    r'select',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _select =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements select(java.lang.String query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Find matching elements within this element list.
  ///@param query A Selector query
  ///@return the filtered list of elements, or an empty list if none match.
  Elements? select(
    jni$_.JString? query,
  ) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _select(
      reference.pointer,
      _id_select as jni$_.JMethodIDPtr,
      _$query.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_not = _class.instanceMethodId(
    r'not',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _not =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements not(java.lang.String query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove elements from this list that match the Selector query.
  ///
  /// E.g. HTML: {@code <div class=logo>One</div> <div>Two</div>}<br>
  /// <code>Elements divs = doc.select("div").not(".logo");</code><br>
  /// Result: {@code divs: [<div>Two</div>]}
  ///
  ///@param query the selector query whose results should be removed from these elements
  ///@return a new elements list that contains only the filtered results
  Elements? not(
    jni$_.JString? query,
  ) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _not(
      reference.pointer,
      _id_not as jni$_.JMethodIDPtr,
      _$query.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_eq = _class.instanceMethodId(
    r'eq',
    r'(I)Lorg/jsoup/select/Elements;',
  );

  static final _eq =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.jsoup.select.Elements eq(int index)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the <i>nth</i> matched element as an Elements object.
  ///
  /// See also \#get(int) to retrieve an Element.
  ///@param index the (zero-based) index of the element in the list to retain
  ///@return Elements containing only the specified element, or, if that element did not exist, an empty list.
  Elements? eq(
    int index,
  ) {
    return _eq(
      reference.pointer,
      _id_eq as jni$_.JMethodIDPtr,
      index,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_is$ = _class.instanceMethodId(
    r'is',
    r'(Ljava/lang/String;)Z',
  );

  static final _is$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean is(java.lang.String query)`
  ///
  /// Test if any of the matched elements match the supplied query.
  ///@param query A selector
  ///@return true if at least one element in the list matches the query.
  bool is$(
    jni$_.JString? query,
  ) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _is$(reference.pointer, _id_is$ as jni$_.JMethodIDPtr, _$query.pointer).boolean;
  }

  static final _id_next = _class.instanceMethodId(
    r'next',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _next =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements next()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the immediate next element sibling of each element in this list.
  ///@return next element siblings.
  Elements? next() {
    return _next(reference.pointer, _id_next as jni$_.JMethodIDPtr).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_next$1 = _class.instanceMethodId(
    r'next',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _next$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements next(java.lang.String query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the immediate next element sibling of each element in this list, filtered by the query.
  ///@param query CSS query to match siblings against
  ///@return next element siblings.
  Elements? next$1(
    jni$_.JString? query,
  ) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _next$1(
      reference.pointer,
      _id_next$1 as jni$_.JMethodIDPtr,
      _$query.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_nextAll = _class.instanceMethodId(
    r'nextAll',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _nextAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements nextAll()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the following element siblings of each element in this list.
  ///@return all following element siblings.
  Elements? nextAll() {
    return _nextAll(
      reference.pointer,
      _id_nextAll as jni$_.JMethodIDPtr,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_nextAll$1 = _class.instanceMethodId(
    r'nextAll',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _nextAll$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements nextAll(java.lang.String query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the following element siblings of each element in this list, that match the query.
  ///@param query CSS query to match siblings against
  ///@return all following element siblings.
  Elements? nextAll$1(
    jni$_.JString? query,
  ) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _nextAll$1(
      reference.pointer,
      _id_nextAll$1 as jni$_.JMethodIDPtr,
      _$query.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_prev = _class.instanceMethodId(
    r'prev',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _prev =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements prev()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the immediate previous element sibling of each element in this list.
  ///@return previous element siblings.
  Elements? prev() {
    return _prev(reference.pointer, _id_prev as jni$_.JMethodIDPtr).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_prev$1 = _class.instanceMethodId(
    r'prev',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _prev$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements prev(java.lang.String query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the immediate previous element sibling of each element in this list, filtered by the query.
  ///@param query CSS query to match siblings against
  ///@return previous element siblings.
  Elements? prev$1(
    jni$_.JString? query,
  ) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _prev$1(
      reference.pointer,
      _id_prev$1 as jni$_.JMethodIDPtr,
      _$query.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_prevAll = _class.instanceMethodId(
    r'prevAll',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _prevAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements prevAll()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the previous element siblings of each element in this list.
  ///@return all previous element siblings.
  Elements? prevAll() {
    return _prevAll(
      reference.pointer,
      _id_prevAll as jni$_.JMethodIDPtr,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_prevAll$1 = _class.instanceMethodId(
    r'prevAll',
    r'(Ljava/lang/String;)Lorg/jsoup/select/Elements;',
  );

  static final _prevAll$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements prevAll(java.lang.String query)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get each of the previous element siblings of each element in this list, that match the query.
  ///@param query CSS query to match siblings against
  ///@return all previous element siblings.
  Elements? prevAll$1(
    jni$_.JString? query,
  ) {
    final _$query = query?.reference ?? jni$_.jNullReference;
    return _prevAll$1(
      reference.pointer,
      _id_prevAll$1 as jni$_.JMethodIDPtr,
      _$query.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_parents = _class.instanceMethodId(
    r'parents',
    r'()Lorg/jsoup/select/Elements;',
  );

  static final _parents =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.select.Elements parents()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get all of the parents and ancestor elements of the matched elements.
  ///@return all of the parents and ancestor elements of the matched elements
  Elements? parents() {
    return _parents(
      reference.pointer,
      _id_parents as jni$_.JMethodIDPtr,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_first = _class.instanceMethodId(
    r'first',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _first =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element first()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the first matched element.
  ///@return The first matched element, or <code>null</code> if contents is empty.
  element$_.Element? first() {
    return _first(
      reference.pointer,
      _id_first as jni$_.JMethodIDPtr,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_last = _class.instanceMethodId(
    r'last',
    r'()Lorg/jsoup/nodes/Element;',
  );

  static final _last =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.Element last()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the last matched element.
  ///@return The last matched element, or <code>null</code> if contents is empty.
  element$_.Element? last() {
    return _last(
      reference.pointer,
      _id_last as jni$_.JMethodIDPtr,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_traverse = _class.instanceMethodId(
    r'traverse',
    r'(Lorg/jsoup/select/NodeVisitor;)Lorg/jsoup/select/Elements;',
  );

  static final _traverse =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements traverse(org.jsoup.select.NodeVisitor nodeVisitor)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Perform a depth-first traversal on each of the selected elements.
  ///@param nodeVisitor the visitor callbacks to perform on each node
  ///@return this, for chaining
  Elements? traverse(
    jni$_.JObject? nodeVisitor,
  ) {
    final _$nodeVisitor = nodeVisitor?.reference ?? jni$_.jNullReference;
    return _traverse(
      reference.pointer,
      _id_traverse as jni$_.JMethodIDPtr,
      _$nodeVisitor.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_filter = _class.instanceMethodId(
    r'filter',
    r'(Lorg/jsoup/select/NodeFilter;)Lorg/jsoup/select/Elements;',
  );

  static final _filter =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.select.Elements filter(org.jsoup.select.NodeFilter nodeFilter)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Perform a depth-first filtering on each of the selected elements.
  ///@param nodeFilter the filter callbacks to perform on each node
  ///@return this, for chaining
  Elements? filter(
    jni$_.JObject? nodeFilter,
  ) {
    final _$nodeFilter = nodeFilter?.reference ?? jni$_.jNullReference;
    return _filter(
      reference.pointer,
      _id_filter as jni$_.JMethodIDPtr,
      _$nodeFilter.pointer,
    ).object<Elements?>(const $Elements$NullableType$());
  }

  static final _id_forms = _class.instanceMethodId(
    r'forms',
    r'()Ljava/util/List;',
  );

  static final _forms =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.FormElement> forms()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the FormElement forms from the selected elements, if any.
  ///@return a list of FormElements pulled from the matched elements. The list will be empty if the elements contain
  /// no forms.
  jni$_.JList<jni$_.JObject?>? forms() {
    return _forms(reference.pointer, _id_forms as jni$_.JMethodIDPtr).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_comments = _class.instanceMethodId(
    r'comments',
    r'()Ljava/util/List;',
  );

  static final _comments =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.Comment> comments()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get Comment nodes that are direct child nodes of the selected elements.
  ///@return Comment nodes, or an empty list if none.
  jni$_.JList<jni$_.JObject?>? comments() {
    return _comments(reference.pointer, _id_comments as jni$_.JMethodIDPtr).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_textNodes = _class.instanceMethodId(
    r'textNodes',
    r'()Ljava/util/List;',
  );

  static final _textNodes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.TextNode> textNodes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get TextNode nodes that are direct child nodes of the selected elements.
  ///@return TextNode nodes, or an empty list if none.
  jni$_.JList<textnode$_.TextNode?>? textNodes() {
    return _textNodes(
      reference.pointer,
      _id_textNodes as jni$_.JMethodIDPtr,
    ).object<jni$_.JList<textnode$_.TextNode?>?>(
      const jni$_.$JList$NullableType$<textnode$_.TextNode?>(textnode$_.$TextNode$NullableType$()),
    );
  }

  static final _id_dataNodes = _class.instanceMethodId(
    r'dataNodes',
    r'()Ljava/util/List;',
  );

  static final _dataNodes =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.util.List<org.jsoup.nodes.DataNode> dataNodes()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get DataNode nodes that are direct child nodes of the selected elements. DataNode nodes contain the
  /// content of tags such as {@code script}, {@code style} etc and are distinct from TextNodes.
  ///@return Comment nodes, or an empty list if none.
  jni$_.JList<jni$_.JObject?>? dataNodes() {
    return _dataNodes(reference.pointer, _id_dataNodes as jni$_.JMethodIDPtr).object<jni$_.JList<jni$_.JObject?>?>(
      const jni$_.$JList$NullableType$<jni$_.JObject?>(jni$_.$JObject$NullableType$()),
    );
  }

  static final _id_set = _class.instanceMethodId(
    r'set',
    r'(ILorg/jsoup/nodes/Element;)Lorg/jsoup/nodes/Element;',
  );

  static final _set =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Int32, jni$_.Pointer<jni$_.Void>)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.nodes.Element set(int index, org.jsoup.nodes.Element element)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Replace the Element at the specified index in this list, and in the DOM.
  ///@param index index of the element to replace
  ///@param element element to be stored at the specified position
  ///@return the old Element at this index
  ///@since 1.17.1
  element$_.Element? set(
    int index,
    element$_.Element? element,
  ) {
    final _$element = element?.reference ?? jni$_.jNullReference;
    return _set(
      reference.pointer,
      _id_set as jni$_.JMethodIDPtr,
      index,
      _$element.pointer,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_remove$1 = _class.instanceMethodId(
    r'remove',
    r'(I)Lorg/jsoup/nodes/Element;',
  );

  static final _remove$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.jsoup.nodes.Element remove(int index)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Remove the Element at the specified index in this ist, and from the DOM.
  ///@param index the index of the element to be removed
  ///@return the old element at this index
  ///@since 1.17.1
  element$_.Element? remove$1(
    int index,
  ) {
    return _remove$1(
      reference.pointer,
      _id_remove$1 as jni$_.JMethodIDPtr,
      index,
    ).object<element$_.Element?>(const element$_.$Element$NullableType$());
  }

  static final _id_remove$2 = _class.instanceMethodId(
    r'remove',
    r'(Ljava/lang/Object;)Z',
  );

  static final _remove$2 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean remove(java.lang.Object o)`
  ///
  /// Remove the specified Element from this list, and from th DOM
  ///@param o element to be removed from this list, if present
  ///@return if this list contained the Element
  ///@since 1.17.1
  bool remove$2(
    jni$_.JObject? o,
  ) {
    final _$o = o?.reference ?? jni$_.jNullReference;
    return _remove$2(reference.pointer, _id_remove$2 as jni$_.JMethodIDPtr, _$o.pointer).boolean;
  }

  static final _id_clear = _class.instanceMethodId(
    r'clear',
    r'()V',
  );

  static final _clear =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public void clear()`
  ///
  /// Removes all the elements from this list, and each of them from the DOM.
  ///@since 1.17.1
  ///@see \#remove()
  void clear() {
    _clear(reference.pointer, _id_clear as jni$_.JMethodIDPtr).check();
  }

  static final _id_removeAll = _class.instanceMethodId(
    r'removeAll',
    r'(Ljava/util/Collection;)Z',
  );

  static final _removeAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean removeAll(java.util.Collection<?> c)`
  ///
  /// Removes from this list, and from the DOM, each of the elements that are contained in the specified collection and
  ///     are in this list.
  ///@param c collection containing elements to be removed from this list
  ///@return {@code true} if elements were removed from this list
  ///@since 1.17.1
  bool removeAll(
    jni$_.JObject? c,
  ) {
    final _$c = c?.reference ?? jni$_.jNullReference;
    return _removeAll(reference.pointer, _id_removeAll as jni$_.JMethodIDPtr, _$c.pointer).boolean;
  }

  static final _id_retainAll = _class.instanceMethodId(
    r'retainAll',
    r'(Ljava/util/Collection;)Z',
  );

  static final _retainAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean retainAll(java.util.Collection<?> c)`
  ///
  /// Retain in this list, and in the DOM, only the elements that are in the specified collection and are in this list.
  ///     In other words, remove elements from this list and the DOM any item that is in this list but not in the specified
  ///     collection.
  ///@param c collection containing elements to be retained in this list
  ///@return {@code true} if elements were removed from this list
  ///@since 1.17.1
  bool retainAll(
    jni$_.JObject? c,
  ) {
    final _$c = c?.reference ?? jni$_.jNullReference;
    return _retainAll(reference.pointer, _id_retainAll as jni$_.JMethodIDPtr, _$c.pointer).boolean;
  }

  static final _id_removeIf = _class.instanceMethodId(
    r'removeIf',
    r'(Ljava/util/function/Predicate;)Z',
  );

  static final _removeIf =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public boolean removeIf(java.util.function.Predicate<? super org.jsoup.nodes.Element> filter)`
  ///
  /// Remove from the list, and from the DOM, all elements in this list that mach the given filter.
  ///@param filter a predicate which returns {@code true} for elements to be removed
  ///@return {@code true} if elements were removed from this list
  ///@since 1.17.1
  bool removeIf(
    jni$_.JObject? filter,
  ) {
    final _$filter = filter?.reference ?? jni$_.jNullReference;
    return _removeIf(reference.pointer, _id_removeIf as jni$_.JMethodIDPtr, _$filter.pointer).boolean;
  }

  static final _id_replaceAll = _class.instanceMethodId(
    r'replaceAll',
    r'(Ljava/util/function/UnaryOperator;)V',
  );

  static final _replaceAll =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JThrowablePtr Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallVoidMethod')
          .asFunction<
            jni$_.JThrowablePtr Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public void replaceAll(java.util.function.UnaryOperator<org.jsoup.nodes.Element> operator)`
  ///
  /// Replace each element in this list with the result of the operator, and update the DOM.
  ///@param operator the operator to apply to each element
  ///@since 1.17.1
  void replaceAll(
    jni$_.JObject? operator,
  ) {
    final _$operator = operator?.reference ?? jni$_.jNullReference;
    _replaceAll(reference.pointer, _id_replaceAll as jni$_.JMethodIDPtr, _$operator.pointer).check();
  }
}

final class $Elements$NullableType$ extends jni$_.JType<Elements?> {
  @jni$_.internal
  const $Elements$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/select/Elements;';

  @jni$_.internal
  @core$_.override
  Elements? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : Elements.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Elements?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Elements$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Elements$NullableType$) && other is $Elements$NullableType$;
  }
}

final class $Elements$Type$ extends jni$_.JType<Elements> {
  @jni$_.internal
  const $Elements$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/select/Elements;';

  @jni$_.internal
  @core$_.override
  Elements fromReference(jni$_.JReference reference) => Elements.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<Elements?> get nullableType => const $Elements$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($Elements$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($Elements$Type$) && other is $Elements$Type$;
  }
}
