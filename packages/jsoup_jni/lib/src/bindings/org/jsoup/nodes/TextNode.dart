// AUTO GENERATED BY JNIGEN 0.15.0. DO NOT EDIT!

// ignore_for_file: annotate_overrides
// ignore_for_file: argument_type_not_assignable
// ignore_for_file: camel_case_extensions
// ignore_for_file: camel_case_types
// ignore_for_file: constant_identifier_names
// ignore_for_file: comment_references
// ignore_for_file: doc_directive_unknown
// ignore_for_file: file_names
// ignore_for_file: inference_failure_on_untyped_parameter
// ignore_for_file: invalid_internal_annotation
// ignore_for_file: invalid_use_of_internal_member
// ignore_for_file: library_prefixes
// ignore_for_file: lines_longer_than_80_chars
// ignore_for_file: no_leading_underscores_for_library_prefixes
// ignore_for_file: no_leading_underscores_for_local_identifiers
// ignore_for_file: non_constant_identifier_names
// ignore_for_file: only_throw_errors
// ignore_for_file: overridden_fields
// ignore_for_file: prefer_double_quotes
// ignore_for_file: unintended_html_in_doc_comment
// ignore_for_file: unnecessary_cast
// ignore_for_file: unnecessary_non_null_assertion
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: unused_element
// ignore_for_file: unused_field
// ignore_for_file: unused_import
// ignore_for_file: unused_local_variable
// ignore_for_file: unused_shown_name
// ignore_for_file: use_super_parameters

import 'dart:core' as core$_;
import 'dart:core' show Object, String, bool, double, int;

import 'package:jni/_internal.dart' as jni$_;
import 'package:jni/jni.dart' as jni$_;

/// from: `org.jsoup.nodes.TextNode`
///
/// A text node.
///@author Jonathan Hedley, jonathan@hedley.net
class TextNode extends jni$_.JObject {
  @jni$_.internal
  @core$_.override
  final jni$_.JType<TextNode> $type;

  @jni$_.internal
  TextNode.fromReference(
    jni$_.JReference reference,
  ) : $type = type,
      super.fromReference(reference);

  static final _class = jni$_.JClass.forName(r'org/jsoup/nodes/TextNode');

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<TextNode?> nullableType = $TextNode$NullableType$();

  /// The type which includes information such as the signature of this class.
  static const jni$_.JType<TextNode> type = $TextNode$Type$();
  static final _id_new$ = _class.constructorId(
    r'(Ljava/lang/String;)V',
  );

  static final _new$ =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_NewObject')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public void <init>(java.lang.String text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new TextNode representing the supplied (unencoded) text).
  ///@param text raw text
  ///@see \#createFromEncoded(String)
  factory TextNode(
    jni$_.JString? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return TextNode.fromReference(
      _new$(_class.reference.pointer, _id_new$ as jni$_.JMethodIDPtr, _$text.pointer).reference,
    );
  }

  static final _id_nodeName = _class.instanceMethodId(
    r'nodeName',
    r'()Ljava/lang/String;',
  );

  static final _nodeName =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String nodeName()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? nodeName() {
    return _nodeName(
      reference.pointer,
      _id_nodeName as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_text = _class.instanceMethodId(
    r'text',
    r'()Ljava/lang/String;',
  );

  static final _text =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String text()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the text content of this text node.
  ///@return Unencoded, normalised text.
  ///@see TextNode\#getWholeText()
  jni$_.JString? text() {
    return _text(
      reference.pointer,
      _id_text as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_text$1 = _class.instanceMethodId(
    r'text',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/TextNode;',
  );

  static final _text$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `public org.jsoup.nodes.TextNode text(java.lang.String text)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Set the text content of this text node.
  ///@param text unencoded text
  ///@return this, for chaining
  TextNode? text$1(
    jni$_.JString? text,
  ) {
    final _$text = text?.reference ?? jni$_.jNullReference;
    return _text$1(
      reference.pointer,
      _id_text$1 as jni$_.JMethodIDPtr,
      _$text.pointer,
    ).object<TextNode?>(const $TextNode$NullableType$());
  }

  static final _id_getWholeText = _class.instanceMethodId(
    r'getWholeText',
    r'()Ljava/lang/String;',
  );

  static final _getWholeText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String getWholeText()`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Get the (unencoded) text of this text node, including any newlines and spaces present in the original.
  ///@return text
  jni$_.JString? getWholeText() {
    return _getWholeText(
      reference.pointer,
      _id_getWholeText as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_isBlank = _class.instanceMethodId(
    r'isBlank',
    r'()Z',
  );

  static final _isBlank =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallBooleanMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public boolean isBlank()`
  ///
  /// Test if this text node is blank -- that is, empty or only whitespace (including newlines).
  ///@return true if this document is empty or only whitespace, false if it contains any text content.
  bool isBlank() {
    return _isBlank(reference.pointer, _id_isBlank as jni$_.JMethodIDPtr).boolean;
  }

  static final _id_splitText = _class.instanceMethodId(
    r'splitText',
    r'(I)Lorg/jsoup/nodes/TextNode;',
  );

  static final _splitText =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.VarArgs<(jni$_.Int32,)>)
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, int)>();

  /// from: `public org.jsoup.nodes.TextNode splitText(int offset)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Split this text node into two nodes at the specified string offset. After splitting, this node will contain the
  /// original text up to the offset, and will have a new text node sibling containing the text after the offset.
  ///@param offset string offset point to split node at.
  ///@return the newly created text node containing the text after the offset.
  TextNode? splitText(
    int offset,
  ) {
    return _splitText(
      reference.pointer,
      _id_splitText as jni$_.JMethodIDPtr,
      offset,
    ).object<TextNode?>(const $TextNode$NullableType$());
  }

  static final _id_toString$1 = _class.instanceMethodId(
    r'toString',
    r'()Ljava/lang/String;',
  );

  static final _toString$1 =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public java.lang.String toString()`
  /// The returned object must be released after use, by calling the [release] method.
  jni$_.JString? toString$1() {
    return _toString$1(
      reference.pointer,
      _id_toString$1 as jni$_.JMethodIDPtr,
    ).object<jni$_.JString?>(const jni$_.$JString$NullableType$());
  }

  static final _id_clone = _class.instanceMethodId(
    r'clone',
    r'()Lorg/jsoup/nodes/TextNode;',
  );

  static final _clone =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
              )
            >
          >('globalEnv_CallObjectMethod')
          .asFunction<
            jni$_.JniResult Function(
              jni$_.Pointer<jni$_.Void>,
              jni$_.JMethodIDPtr,
            )
          >();

  /// from: `public org.jsoup.nodes.TextNode clone()`
  /// The returned object must be released after use, by calling the [release] method.
  TextNode? clone() {
    return _clone(
      reference.pointer,
      _id_clone as jni$_.JMethodIDPtr,
    ).object<TextNode?>(const $TextNode$NullableType$());
  }

  static final _id_createFromEncoded = _class.staticMethodId(
    r'createFromEncoded',
    r'(Ljava/lang/String;)Lorg/jsoup/nodes/TextNode;',
  );

  static final _createFromEncoded =
      jni$_.ProtectedJniExtensions.lookup<
            jni$_.NativeFunction<
              jni$_.JniResult Function(
                jni$_.Pointer<jni$_.Void>,
                jni$_.JMethodIDPtr,
                jni$_.VarArgs<(jni$_.Pointer<jni$_.Void>,)>,
              )
            >
          >('globalEnv_CallStaticObjectMethod')
          .asFunction<
            jni$_.JniResult Function(jni$_.Pointer<jni$_.Void>, jni$_.JMethodIDPtr, jni$_.Pointer<jni$_.Void>)
          >();

  /// from: `static public org.jsoup.nodes.TextNode createFromEncoded(java.lang.String encodedText)`
  /// The returned object must be released after use, by calling the [release] method.
  ///
  /// Create a new TextNode from HTML encoded (aka escaped) data.
  ///@param encodedText Text containing encoded HTML (e.g. {@code &lt;})
  ///@return TextNode containing unencoded data (e.g. {@code <})
  static TextNode? createFromEncoded(
    jni$_.JString? encodedText,
  ) {
    final _$encodedText = encodedText?.reference ?? jni$_.jNullReference;
    return _createFromEncoded(
      _class.reference.pointer,
      _id_createFromEncoded as jni$_.JMethodIDPtr,
      _$encodedText.pointer,
    ).object<TextNode?>(const $TextNode$NullableType$());
  }
}

final class $TextNode$NullableType$ extends jni$_.JType<TextNode?> {
  @jni$_.internal
  const $TextNode$NullableType$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/TextNode;';

  @jni$_.internal
  @core$_.override
  TextNode? fromReference(jni$_.JReference reference) => reference.isNull
      ? null
      : TextNode.fromReference(
          reference,
        );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<TextNode?> get nullableType => this;

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TextNode$NullableType$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TextNode$NullableType$) && other is $TextNode$NullableType$;
  }
}

final class $TextNode$Type$ extends jni$_.JType<TextNode> {
  @jni$_.internal
  const $TextNode$Type$();

  @jni$_.internal
  @core$_.override
  String get signature => r'Lorg/jsoup/nodes/TextNode;';

  @jni$_.internal
  @core$_.override
  TextNode fromReference(jni$_.JReference reference) => TextNode.fromReference(
    reference,
  );
  @jni$_.internal
  @core$_.override
  jni$_.JType get superType => const jni$_.$JObject$NullableType$();

  @jni$_.internal
  @core$_.override
  jni$_.JType<TextNode?> get nullableType => const $TextNode$NullableType$();

  @jni$_.internal
  @core$_.override
  final superCount = 1;

  @core$_.override
  int get hashCode => ($TextNode$Type$).hashCode;

  @core$_.override
  bool operator ==(Object other) {
    return other.runtimeType == ($TextNode$Type$) && other is $TextNode$Type$;
  }
}
